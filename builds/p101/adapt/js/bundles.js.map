{"version":3,"sources":["../../../src/extensions/adapt-contrib-pageLevelProgress/js/completionCalculations.js","../../../src/extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressMenuView.js","../../../src/extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressView.js","../../../src/extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressNavigationView.js","../../../src/extensions/adapt-contrib-pageLevelProgress/js/adapt-contrib-pageLevelProgress.js","../../../src/extensions/adapt-contrib-resources/js/adapt-contrib-resourcesView.js","../../../src/extensions/adapt-contrib-resources/js/adapt-contrib-resourcesHelpers.js","../../../src/extensions/adapt-contrib-resources/js/adapt-contrib-resources.js","../../../src/extensions/adapt-contrib-spoor/js/scorm/API.js","../../../src/extensions/adapt-contrib-spoor/js/scorm/wrapper.js","../../../src/extensions/adapt-contrib-spoor/js/scorm/logger.js","../../../src/extensions/adapt-contrib-spoor/js/scorm.js","../../../src/extensions/adapt-contrib-spoor/js/serializers/default.js","../../../src/extensions/adapt-contrib-spoor/js/serializers/scormSuspendDataSerializer.js","../../../src/extensions/adapt-contrib-spoor/js/serializers/questions.js","../../../src/extensions/adapt-contrib-spoor/js/adapt-stateful-session.js","../../../src/extensions/adapt-contrib-spoor/js/adapt-offlineStorage-scorm.js","../../../src/extensions/adapt-contrib-spoor/js/adapt-contrib-spoor.js","../../../src/extensions/adapt-contrib-trickle/js/Defaults/DefaultTrickleConfig.js","../../../src/extensions/adapt-contrib-trickle/js/DataTypes/StructureType.js","../../../src/extensions/adapt-contrib-trickle/js/Utility/Models.js","../../../src/extensions/adapt-contrib-trickle/js/trickle-tutorPlugin.js","../../../src/extensions/adapt-contrib-trickle/js/trickle-buttonView.js","../../../src/extensions/adapt-contrib-trickle/js/Defaults/FullWidthButtonConstants.js","../../../src/extensions/adapt-contrib-trickle/js/trickle-buttonModel.js","../../../src/extensions/adapt-contrib-trickle/js/trickle-buttonPlugin.js","../../../src/extensions/adapt-contrib-trickle/js/lib/jquery.resize.js","../../../src/extensions/adapt-contrib-trickle/js/adapt-contrib-trickle.js","../../../src/extensions/adapt-contrib-tutor/js/adapt-contrib-tutor.js","../../../src/components/adapt-contrib-accordion/js/adapt-contrib-accordion.js","../../../src/components/adapt-contrib-text/js/adapt-contrib-text.js","../../../src/menu/adapt-contrib-boxmenu/js/adapt-contrib-boxmenu.js","../../../src/theme/adapt-contrib-vanilla/js/theme-block.js","../../../src/theme/adapt-contrib-vanilla/js/vanilla.js","../../../src/bundles.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC50BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1gCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundles.js","sourcesContent":["define('extensions/adapt-contrib-pageLevelProgress/js/completionCalculations',[],function() {\n    \n    // Calculate completion of a contentObject\n    function calculateCompletion(contentObjectModel) {\n\n        var viewType = contentObjectModel.get('_type'),\n            nonAssessmentComponentsTotal = 0,\n            nonAssessmentComponentsCompleted = 0,\n            assessmentComponentsTotal = 0,\n            assessmentComponentsCompleted = 0,\n            subProgressCompleted = 0,\n            subProgressTotal = 0,\n            isComplete = contentObjectModel.get(\"_isComplete\") ? 1 : 0;\n\n        // If it's a page\n        if (viewType == 'page') {\n            var children = contentObjectModel.findDescendants('components').where({'_isAvailable': true, '_isOptional': false});\n            var components = getPageLevelProgressEnabledModels(children);\n\n            var nonAssessmentComponents = getNonAssessmentComponents(components);\n\n            nonAssessmentComponentsTotal = nonAssessmentComponents.length | 0,\n            nonAssessmentComponentsCompleted = getComponentsCompleted(nonAssessmentComponents).length;\n\n            var assessmentComponents = getAssessmentComponents(components);\n\n            assessmentComponentsTotal = assessmentComponents.length | 0,\n            assessmentComponentsCompleted = getComponentsInteractionCompleted(assessmentComponents).length;\n\n            subProgressCompleted = contentObjectModel.get(\"_subProgressComplete\") || 0;\n            subProgressTotal = contentObjectModel.get(\"_subProgressTotal\") || 0;\n\n            //add one point extra for page completion to eliminate incomplete pages and full progress bars\n            return {\n                \"subProgressCompleted\": subProgressCompleted,\n                \"subProgressTotal\": subProgressTotal,\n                \"nonAssessmentCompleted\": nonAssessmentComponentsCompleted + isComplete,\n                \"nonAssessmentTotal\": nonAssessmentComponentsTotal + 1,\n                \"assessmentCompleted\": assessmentComponentsCompleted + isComplete,\n                \"assessmentTotal\": assessmentComponentsTotal + 1\n            };\n        }\n        // If it's a sub-menu\n        else if (viewType == 'menu') {\n\n            _.each(contentObjectModel.get('_children').models, function(contentObject) {\n                var completionObject = calculateCompletion(contentObject);\n                subProgressCompleted += contentObjectModel.subProgressCompleted || 0;\n                subProgressTotal += contentObjectModel.subProgressTotal || 0;\n                nonAssessmentComponentsTotal += completionObject.nonAssessmentTotal;\n                nonAssessmentComponentsCompleted += completionObject.nonAssessmentCompleted;\n                assessmentComponentsTotal += completionObject.assessmentTotal;\n                assessmentComponentsCompleted += completionObject.assessmentCompleted;\n            });\n\n            return {\n                \"subProgressCompleted\": subProgressCompleted,\n                \"subProgressTotal\" : subProgressTotal,\n                \"nonAssessmentCompleted\": nonAssessmentComponentsCompleted,\n                \"nonAssessmentTotal\": nonAssessmentComponentsTotal,\n                \"assessmentCompleted\": assessmentComponentsCompleted,\n                \"assessmentTotal\": assessmentComponentsTotal,\n            };\n        }\n    }\n\n    function getNonAssessmentComponents(models) {\n        return _.filter(models, function(model) {\n            return !model.get('_isPartOfAssessment');\n        });\n    }\n\n    function getAssessmentComponents(models) {\n        return _.filter(models, function(model) {\n            return model.get('_isPartOfAssessment');\n        });\n    }\n\n    function getComponentsCompleted(models) {\n        return _.filter(models, function(item) {\n            return item.get('_isComplete');\n        });\n    }\n\n    function getComponentsInteractionCompleted(models) {\n        return _.filter(models, function(item) {\n            return item.get('_isInteractionComplete');\n        });\n    }\n\n    //Get only those models who were enabled for pageLevelProgress\n    function getPageLevelProgressEnabledModels(models) {\n        return _.filter(models, function(model) {\n            if (model.get('_pageLevelProgress')) {\n                return model.get('_pageLevelProgress')._isEnabled;\n            }\n        });\n    }\n\n    return {\n    \tcalculateCompletion: calculateCompletion,\n    \tgetPageLevelProgressEnabledModels: getPageLevelProgressEnabledModels\n    };\n\n});\n","define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressMenuView',['require','coreJS/adapt','backbone'],function(require) {\n\n    var Adapt = require('coreJS/adapt');\n    var Backbone = require('backbone');\n\n    var PageLevelProgressMenuView = Backbone.View.extend({\n\n        className: 'page-level-progress-menu-item',\n\n        initialize: function() {\n            this.listenTo(Adapt, 'remove', this.remove);\n\n            this.ariaText = '';\n            if (Adapt.course.get('_globals')._extensions && Adapt.course.get('_globals')._extensions._pageLevelProgress && Adapt.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressMenuBar) {\n                this.ariaText = Adapt.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressMenuBar + ' ';\n            }\n\n            this.render();\n\n            _.defer(_.bind(function() {\n                this.updateProgressBar();\n            }, this));\n        },\n\n        events: {\n        },\n\n        render: function() {\n            var data = this.model.toJSON();\n            _.extend(data, {\n                _globals: Adapt.course.get('_globals')\n            });\n            var template = Handlebars.templates['pageLevelProgressMenu'];\n\n            this.$el.html(template(data));\n            return this;\n        },\n\n        updateProgressBar: function() {\n            if (this.model.get('completedChildrenAsPercentage')) {\n                var percentageOfCompleteComponents = this.model.get('completedChildrenAsPercentage');\n            } else {\n                var percentageOfCompleteComponents = 0;\n            }\n\n            // Add percentage of completed components as an aria label attribute\n            this.$('.page-level-progress-menu-item-indicator-bar .aria-label').html(this.ariaText + Math.floor(percentageOfCompleteComponents) + '%');\n\n        },\n\n    });\n\n    return PageLevelProgressMenuView;\n\n});\n\n","define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressView',['require','coreJS/adapt','backbone'],function(require) {\n\n    var Adapt = require('coreJS/adapt');\n    var Backbone = require('backbone');\n\n    var PageLevelProgressView = Backbone.View.extend({\n\n        className: 'page-level-progress',\n\n        initialize: function() {\n            this.listenTo(Adapt, 'remove', this.remove);\n            this.render();\n        },\n\n        events: {\n            'click .page-level-progress-item button': 'scrollToPageElement'\n        },\n\n        scrollToPageElement: function(event) {\n            if(event && event.preventDefault) event.preventDefault();\n            var currentComponentSelector = '.' + $(event.currentTarget).attr('data-page-level-progress-id');\n            var $currentComponent = $(currentComponentSelector);\n            Adapt.once('drawer:closed', function() {\n                Adapt.scrollTo($currentComponent, { duration:400 });\n            });\n            Adapt.trigger('drawer:closeDrawer');\n        },\n\n        render: function() {\n            var components = this.collection.toJSON();\n            var data = {\n                components: components,\n                _globals: Adapt.course.get('_globals')\n            };\n            var template = Handlebars.templates['pageLevelProgress'];\n            this.$el.html(template(data));\n            this.$el.a11y_aria_label(true);\n            return this;\n        }\n\n    });\n\n    return PageLevelProgressView;\n\n});\n\n","define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressNavigationView',['require','coreJS/adapt','backbone','./completionCalculations','extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressView'],function(require) {\n\n    var Adapt = require('coreJS/adapt');\n    var Backbone = require('backbone');\n    var completionCalculations = require('./completionCalculations');\n\n    var PageLevelProgressView = require('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressView');\n\n    var PageLevelProgressNavigationView = Backbone.View.extend({\n\n        tagName: 'button',\n\n        className: 'base page-level-progress-navigation',\n\n        initialize: function() {\n            this.listenTo(Adapt, 'remove', this.remove);\n            this.listenTo(Adapt, 'router:location', this.updateProgressBar);\n            this.listenTo(Adapt, 'pageLevelProgress:update', this.refreshProgressBar);\n            this.listenTo(this.collection, 'change:_isInteractionComplete', this.updateProgressBar);\n            this.listenTo(this.model, 'change:_isInteractionComplete', this.updateProgressBar);\n            this.$el.attr('role', 'button');\n            this.ariaText = '';\n            \n            if (Adapt.course.has('_globals') && Adapt.course.get('_globals')._extensions && Adapt.course.get('_globals')._extensions._pageLevelProgress && Adapt.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressIndicatorBar) {\n                this.ariaText = Adapt.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressIndicatorBar +  ' ';\n            }\n            \n            this.render();\n            \n            _.defer(_.bind(function() {\n                this.updateProgressBar();\n            }, this));\n        },\n\n        events: {\n            'click': 'onProgressClicked'\n        },\n\n        render: function() {\n            var components = this.collection.toJSON();\n            var data = {\n                components: components,\n                _globals: Adapt.course.get('_globals')\n            };            \n\n            var template = Handlebars.templates['pageLevelProgressNavigation'];\n            $('.navigation-drawer-toggle-button').after(this.$el.html(template(data)));\n            return this;\n        },\n        \n        refreshProgressBar: function() {\n            var currentPageComponents = this.model.findDescendants('components').where({'_isAvailable': true});\n            var enabledProgressComponents = completionCalculations.getPageLevelProgressEnabledModels(currentPageComponents);\n            \n            this.collection = new Backbone.Collection(enabledProgressComponents);\n            this.updateProgressBar();\n        },\n\n        updateProgressBar: function() {\n            var completionObject = completionCalculations.calculateCompletion(this.model);\n            \n            //take all assessment, nonassessment and subprogress into percentage\n            //this allows the user to see if assessments have been passed, if assessment components can be retaken, and all other component's completion\n            \n            var completed = completionObject.nonAssessmentCompleted + completionObject.assessmentCompleted + completionObject.subProgressCompleted;\n            var total  = completionObject.nonAssessmentTotal + completionObject.assessmentTotal + completionObject.subProgressTotal;\n\n            var percentageComplete = Math.floor((completed / total)*100);\n\n\n            this.$('.page-level-progress-navigation-bar').css('width', percentageComplete + '%');\n\n            // Add percentage of completed components as an aria label attribute\n            this.$el.attr('aria-label', this.ariaText +  percentageComplete + '%');\n\n            // Set percentage of completed components to model attribute to update progress on MenuView\n            this.model.set('completedChildrenAsPercentage', percentageComplete);\n        },\n\n        onProgressClicked: function(event) {\n            if(event && event.preventDefault) event.preventDefault();\n            Adapt.drawer.triggerCustomView(new PageLevelProgressView({collection: this.collection}).$el, false);\n        }\n\n    });\n\n    return PageLevelProgressNavigationView;\n\n});\n\n","define('extensions/adapt-contrib-pageLevelProgress/js/adapt-contrib-pageLevelProgress',['require','coreJS/adapt','backbone','./completionCalculations','extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressMenuView','extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressNavigationView'],function(require) {\n\n    var Adapt = require('coreJS/adapt');\n    var Backbone = require('backbone');\n    var completionCalculations = require('./completionCalculations');\n\n    var PageLevelProgressMenuView = require('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressMenuView');\n    var PageLevelProgressNavigationView = require('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressNavigationView');\n\n    function setupPageLevelProgress(pageModel, enabledProgressComponents) {\n\n        new PageLevelProgressNavigationView({model: pageModel, collection:  new Backbone.Collection(enabledProgressComponents) });\n\n    }\n\n    // This should add/update progress on menuView\n    Adapt.on('menuView:postRender', function(view) {\n\n        if (view.model.get('_id') == Adapt.location._currentId) return;\n\n        // do not proceed until pageLevelProgress enabled on course.json\n        if (!Adapt.course.get('_pageLevelProgress') || !Adapt.course.get('_pageLevelProgress')._isEnabled) {\n            return;\n        }\n\n        var pageLevelProgress = view.model.get('_pageLevelProgress');\n        var viewType = view.model.get('_type');\n\n        // Progress bar should not render for course viewType\n        if (viewType == 'course') return;\n\n        if (pageLevelProgress && pageLevelProgress._isEnabled) {\n\n            var completionObject = completionCalculations.calculateCompletion(view.model);\n\n            //take all non-assessment components and subprogress info into the percentage\n            //this allows the user to see if the assessments are passed (subprogress) and all other components are complete\n            \n            var completed = completionObject.nonAssessmentCompleted + completionObject.subProgressCompleted;\n            var total = completionObject.nonAssessmentTotal + completionObject.subProgressTotal;\n\n            var percentageComplete = Math.floor((completed / total)*100);\n            \n            view.model.set('completedChildrenAsPercentage', percentageComplete);\n            view.$el.find('.menu-item-inner').append(new PageLevelProgressMenuView({model: view.model}).$el);\n\n        }\n\n    });\n\n    // This should add/update progress on page navigation bar\n    Adapt.on('router:page', function(pageModel) {\n\n        // do not proceed until pageLevelProgress enabled on course.json\n        if (!Adapt.course.get('_pageLevelProgress') || !Adapt.course.get('_pageLevelProgress')._isEnabled) {\n            return;\n        }\n\n        var currentPageComponents = pageModel.findDescendants('components').where({'_isAvailable': true});\n        var enabledProgressComponents = completionCalculations.getPageLevelProgressEnabledModels(currentPageComponents);\n\n        if (enabledProgressComponents.length > 0) {\n            setupPageLevelProgress(pageModel, enabledProgressComponents);\n        }\n\n    });\n\n});\n\n","define('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesView',['require','backbone','coreJS/adapt'],function(require) {\n\n    var Backbone = require('backbone');\n    var Adapt = require('coreJS/adapt');\n\n    var ResourcesView = Backbone.View.extend({\n\n        className: \"resources\",\n\n        initialize: function() {\n            this.listenTo(Adapt, 'remove', this.remove);\n            this.render();\n        },\n\n        events: {\n            'click .resources-filter button': 'onFilterClicked',\n            'click .resources-item-container button': 'onResourceClicked'\n        },\n\n        render: function() {\n            var collectionData = this.collection.toJSON();\n            var modelData = this.model.toJSON();\n            var template = Handlebars.templates[\"resources\"];\n            this.$el.html(template({model: modelData, resources:collectionData, _globals: Adapt.course.get('_globals')}));\n            _.defer(_.bind(this.postRender, this));\n            return this;\n        },\n\n        postRender: function() {\n            this.listenTo(Adapt, 'drawer:triggerCustomView', this.remove);\n        },\n\n        onFilterClicked: function(event) {\n            event.preventDefault();\n            var $currentTarget = $(event.currentTarget);\n            this.$('.resources-filter button').removeClass('selected');\n            var filter = $currentTarget.addClass('selected').attr('data-filter');\n            var items = [];\n\n            if (filter === 'all') {\n                items = this.$('.resources-item').removeClass('display-none');\n            } else {\n                this.$('.resources-item').removeClass('display-none').not(\".\" + filter).addClass('display-none');\n                items = this.$('.resources-item.' + filter);\n            }\n\n            if (items.length === 0) return;\n            $(items[0]).a11y_focus();\n        },\n\n        onResourceClicked: function(event) {\n            window.open($(event.currentTarget).data(\"href\"));\n        }\n    });\n\n    return ResourcesView;\n})\n;\n","define('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesHelpers',['require','handlebars'],function(require) {\n\n\tvar Handlebars = require('handlebars');\n\n\tHandlebars.registerHelper('if_collection_contains', function(collection, attribute, value, block) {\n\t\tvar makeBlockVisible = false;\n\n\t\t_.each(collection, function(resource) {\n\t\t\tif (resource[attribute] === value) {\n\t\t\t\tmakeBlockVisible = true;\n\t\t\t}\n\t\t});\n\t\tif(makeBlockVisible) {\n            return block.fn(this);\n        } else {\n            return block.inverse();\n        }\n    });\n\n    Handlebars.registerHelper('if_collection_contains_only_one_item', function(collection, attribute, block) {\n\t\tvar attributeCount = [];\n\n\t\t_.each(collection, function(resource) {\n\t\t\tvar resourceAttribute = resource[attribute];\n\t\t\tif (_.indexOf(attributeCount, resourceAttribute) === -1) {\n\t\t\t\tattributeCount.push(resourceAttribute);\n\t\t\t}\n\t\t});\n\n\t\tif (attributeCount.length <= 1) {\n\t\t\treturn block.fn(this);\n\t\t} else {\n\t\t\treturn block.inverse(this);\n\t\t}\n\n    });\n\n    Handlebars.registerHelper('return_column_layout_from_collection_length', function(collection, attribute) {\n\t\tvar attributeCount = [];\n\n\t\t_.each(collection, function(resource) {\n\t\t\tvar resourceAttribute = resource[attribute];\n\t\t\tif (_.indexOf(attributeCount, resourceAttribute) === -1) {\n\t\t\t\tattributeCount.push(resourceAttribute);\n\t\t\t}\n\t\t});\n\n\t\treturn (attributeCount.length + 1);\n\n    });\n\n})\n\t;\n","define('extensions/adapt-contrib-resources/js/adapt-contrib-resources',['require','coreJS/adapt','backbone','extensions/adapt-contrib-resources/js/adapt-contrib-resourcesView','extensions/adapt-contrib-resources/js/adapt-contrib-resourcesHelpers'],function(require) {\n\n\tvar Adapt = require('coreJS/adapt');\n\tvar Backbone = require('backbone');\n\tvar ResourcesView = require('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesView');\n\tvar ResourcesHelpers = require('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesHelpers');\n\n\tfunction setupResources(resourcesModel, resourcesItems) {\n\n\t\tvar resourcesCollection = new Backbone.Collection(resourcesItems);\n\t\tvar resourcesModel = new Backbone.Model(resourcesModel);\n\n\t\tAdapt.on('resources:showResources', function() {\n\t\t\tAdapt.drawer.triggerCustomView(new ResourcesView({\n\t\t\t\tmodel: resourcesModel, \n\t\t\t\tcollection: resourcesCollection\n\t\t\t}).$el);\n\t\t});\n\t\n\t}\n\n\tAdapt.once('app:dataReady', function() {\n\n\t\tvar courseResources = Adapt.course.get('_resources');\n\n\t\tif (courseResources) {\n\t\t\tvar drawerObject = {\n\t\t        title: courseResources.title,\n\t\t        description: courseResources.description,\n\t\t        className: 'resources-drawer'\n\t\t    };\n\t\t    // Syntax for adding a Drawer item\n\t\t    // Adapt.drawer.addItem([object], [callbackEvent]);\n\t\t    Adapt.drawer.addItem(drawerObject, 'resources:showResources');\n\t\t} else {\n\t\t\treturn console.log('Sorry, no resources object is set on the course.json file');\n\t\t}\n\n\t\tsetupResources(courseResources, courseResources._resourcesItems);\n\n\t});\n\n});\n","/*global console*/\n\n/* ===========================================================\n\npipwerks SCORM Wrapper for JavaScript\nv1.1.20150614\n\nCreated by Philip Hutchison, January 2008-2014\nhttps://github.com/pipwerks/scorm-api-wrapper\n\nCopyright (c) Philip Hutchison\nMIT-style license: http://pipwerks.mit-license.org/\n\nThis wrapper works with both SCORM 1.2 and SCORM 2004.\n\nInspired by APIWrapper.js, created by the ADL and\nConcurrent Technologies Corporation, distributed by\nthe ADL (http://www.adlnet.gov/scorm).\n\nSCORM.API.find() and SCORM.API.get() functions based\non ADL code, modified by Mike Rustici\n(http://www.scorm.com/resources/apifinder/SCORMAPIFinder.htm),\nfurther modified by Philip Hutchison\n\n=============================================================== */\n\n\nvar pipwerks = {};                                  //pipwerks 'namespace' helps ensure no conflicts with possible other \"SCORM\" variables\npipwerks.UTILS = {};                                //For holding UTILS functions\npipwerks.debug = { isActive: true };                //Enable (true) or disable (false) for debug mode\n\npipwerks.SCORM = {                                  //Define the SCORM object\n    version:    null,                               //Store SCORM version.\n    handleCompletionStatus: true,                   //Whether or not the wrapper should automatically handle the initial completion status\n    handleExitMode: true,                           //Whether or not the wrapper should automatically handle the exit mode\n    API:        { handle: null,\n                  isFound: false },                 //Create API child object\n    connection: { isActive: false },                //Create connection child object\n    data:       { completionStatus: null,\n                  exitStatus: null },               //Create data child object\n    debug:      {}                                  //Create debug child object\n};\n\n\n\n/* --------------------------------------------------------------------------------\n   pipwerks.SCORM.isAvailable\n   A simple function to allow Flash ExternalInterface to confirm\n   presence of JS wrapper before attempting any LMS communication.\n\n   Parameters: none\n   Returns:    Boolean (true)\n----------------------------------------------------------------------------------- */\n\npipwerks.SCORM.isAvailable = function(){\n    return true;\n};\n\n\n\n// ------------------------------------------------------------------------- //\n// --- SCORM.API functions ------------------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.API.find(window)\n   Looks for an object named API in parent and opener windows\n\n   Parameters: window (the browser window object).\n   Returns:    Object if API is found, null if no API found\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.API.find = function(win){\n\n    var API = null,\n        findAttempts = 0,\n        findAttemptLimit = 500,\n        traceMsgPrefix = \"SCORM.API.find\",\n        trace = pipwerks.UTILS.trace,\n        scorm = pipwerks.SCORM;\n\n    while ((!win.API && !win.API_1484_11) &&\n           (win.parent) &&\n           (win.parent != win) &&\n           (findAttempts <= findAttemptLimit)){\n\n                findAttempts++;\n                win = win.parent;\n\n    }\n\n    //If SCORM version is specified by user, look for specific API\n    if(scorm.version){\n\n        switch(scorm.version){\n\n            case \"2004\" :\n\n                if(win.API_1484_11){\n\n                    API = win.API_1484_11;\n\n                } else {\n\n                    trace(traceMsgPrefix +\": SCORM version 2004 was specified by user, but API_1484_11 cannot be found.\");\n\n                }\n\n                break;\n\n            case \"1.2\" :\n\n                if(win.API){\n\n                    API = win.API;\n\n                } else {\n\n                    trace(traceMsgPrefix +\": SCORM version 1.2 was specified by user, but API cannot be found.\");\n\n                }\n\n                break;\n\n        }\n\n    } else {                             //If SCORM version not specified by user, look for APIs\n\n        if(win.API_1484_11) {            //SCORM 2004-specific API.\n\n            scorm.version = \"2004\";      //Set version\n            API = win.API_1484_11;\n\n        } else if(win.API){              //SCORM 1.2-specific API\n\n            scorm.version = \"1.2\";       //Set version\n            API = win.API;\n\n        }\n\n    }\n\n    if(API){\n\n        trace(traceMsgPrefix +\": API found. Version: \" +scorm.version);\n        trace(\"API: \" +API);\n\n    } else {\n\n        trace(traceMsgPrefix +\": Error finding API. \\nFind attempts: \" +findAttempts +\". \\nFind attempt limit: \" +findAttemptLimit);\n\n    }\n\n    return API;\n\n};\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.API.get()\n   Looks for an object named API, first in the current window's frame\n   hierarchy and then, if necessary, in the current window's opener window\n   hierarchy (if there is an opener window).\n\n   Parameters:  None.\n   Returns:     Object if API found, null if no API found\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.API.get = function(){\n\n    var API = null,\n        win = window,\n        scorm = pipwerks.SCORM,\n        find = scorm.API.find,\n        trace = pipwerks.UTILS.trace;\n\n    API = find(win);\n\n    if(!API && win.parent && win.parent != win){\n        API = find(win.parent);\n    }\n\n    if(!API && win.top && win.top.opener){\n        API = find(win.top.opener);\n    }\n\n    //Special handling for Plateau\n    //Thanks to Joseph Venditti for the patch\n    if(!API && win.top && win.top.opener && win.top.opener.document) {\n        API = find(win.top.opener.document);\n    }\n\n    if(API){\n        scorm.API.isFound = true;\n    } else {\n        trace(\"API.get failed: Can't find the API!\");\n    }\n\n    return API;\n\n};\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.API.getHandle()\n   Returns the handle to API object if it was previously set\n\n   Parameters:  None.\n   Returns:     Object (the pipwerks.SCORM.API.handle variable).\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.API.getHandle = function() {\n\n    var API = pipwerks.SCORM.API;\n\n    if(!API.handle && !API.isFound){\n\n        API.handle = API.get();\n\n    }\n\n    return API.handle;\n\n};\n\n\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.SCORM.connection functions --------------------------------- //\n// ------------------------------------------------------------------------- //\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.connection.initialize()\n   Tells the LMS to initiate the communication session.\n\n   Parameters:  None\n   Returns:     Boolean\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.connection.initialize = function(){\n\n    var success = false,\n        scorm = pipwerks.SCORM,\n        completionStatus = scorm.data.completionStatus,\n        trace = pipwerks.UTILS.trace,\n        makeBoolean = pipwerks.UTILS.StringToBoolean,\n        debug = scorm.debug,\n        traceMsgPrefix = \"SCORM.connection.initialize \";\n\n    trace(\"connection.initialize called.\");\n\n    if(!scorm.connection.isActive){\n\n        var API = scorm.API.getHandle(),\n            errorCode = 0;\n\n        if(API){\n\n            switch(scorm.version){\n                case \"1.2\" : success = makeBoolean(API.LMSInitialize(\"\")); break;\n                case \"2004\": success = makeBoolean(API.Initialize(\"\")); break;\n            }\n\n            if(success){\n\n                //Double-check that connection is active and working before returning 'true' boolean\n                errorCode = debug.getCode();\n\n                if(errorCode !== null && errorCode === 0){\n\n                    scorm.connection.isActive = true;\n\n                    if(scorm.handleCompletionStatus){\n\n                        //Automatically set new launches to incomplete\n                        completionStatus = scorm.status(\"get\");\n\n                        if(completionStatus){\n\n                            switch(completionStatus){\n\n                                //Both SCORM 1.2 and 2004\n                                case \"not attempted\": scorm.status(\"set\", \"incomplete\"); break;\n\n                                //SCORM 2004 only\n                                case \"unknown\" : scorm.status(\"set\", \"incomplete\"); break;\n\n                                //Additional options, presented here in case you'd like to use them\n                                //case \"completed\"  : break;\n                                //case \"incomplete\" : break;\n                                //case \"passed\"     : break;    //SCORM 1.2 only\n                                //case \"failed\"     : break;    //SCORM 1.2 only\n                                //case \"browsed\"    : break;    //SCORM 1.2 only\n\n                            }\n\n                            //Commit changes\n                            scorm.save();\n\n                        }\n\n                    }\n\n                } else {\n\n                    success = false;\n                    trace(traceMsgPrefix +\"failed. \\nError code: \" +errorCode +\" \\nError info: \" +debug.getInfo(errorCode));\n\n                }\n\n            } else {\n\n                errorCode = debug.getCode();\n\n                if(errorCode !== null && errorCode !== 0){\n\n                    trace(traceMsgPrefix +\"failed. \\nError code: \" +errorCode +\" \\nError info: \" +debug.getInfo(errorCode));\n\n                } else {\n\n                    trace(traceMsgPrefix +\"failed: No response from server.\");\n\n                }\n            }\n\n        } else {\n\n            trace(traceMsgPrefix +\"failed: API is null.\");\n\n        }\n\n    } else {\n\n          trace(traceMsgPrefix +\"aborted: Connection already active.\");\n\n     }\n\n     return success;\n\n};\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.connection.terminate()\n   Tells the LMS to terminate the communication session\n\n   Parameters:  None\n   Returns:     Boolean\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.connection.terminate = function(){\n\n    var success = false,\n        scorm = pipwerks.SCORM,\n        exitStatus = scorm.data.exitStatus,\n        completionStatus = scorm.data.completionStatus,\n        trace = pipwerks.UTILS.trace,\n        makeBoolean = pipwerks.UTILS.StringToBoolean,\n        debug = scorm.debug,\n        traceMsgPrefix = \"SCORM.connection.terminate \";\n\n\n    if(scorm.connection.isActive){\n\n        var API = scorm.API.getHandle(),\n            errorCode = 0;\n\n        if(API){\n\n             if(scorm.handleExitMode && !exitStatus){\n\n                if(completionStatus !== \"completed\" && completionStatus !== \"passed\"){\n\n                    switch(scorm.version){\n                        case \"1.2\" : success = scorm.set(\"cmi.core.exit\", \"suspend\"); break;\n                        case \"2004\": success = scorm.set(\"cmi.exit\", \"suspend\"); break;\n                    }\n\n                } else {\n\n                    switch(scorm.version){\n                        case \"1.2\" : success = scorm.set(\"cmi.core.exit\", \"logout\"); break;\n                        case \"2004\": success = scorm.set(\"cmi.exit\", \"normal\"); break;\n                    }\n\n                }\n\n            }\n\n            //Ensure we persist the data\n            success = scorm.save();\n\n            if(success){\n     \n                switch(scorm.version){\n                    case \"1.2\" : success = makeBoolean(API.LMSFinish(\"\")); break;\n                    case \"2004\": success = makeBoolean(API.Terminate(\"\")); break;\n                }\n                   \n                if(success){\n                        \n                    scorm.connection.isActive = false;\n                   \n                } else {\n                        \n                    errorCode = debug.getCode();\n                    trace(traceMsgPrefix +\"failed. \\nError code: \" +errorCode +\" \\nError info: \" +debug.getInfo(errorCode));\n       \n                }\n                \n            }\n\n        } else {\n\n            trace(traceMsgPrefix +\"failed: API is null.\");\n\n        }\n\n    } else {\n\n        trace(traceMsgPrefix +\"aborted: Connection already terminated.\");\n\n    }\n\n    return success;\n\n};\n\n\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.SCORM.data functions --------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.data.get(parameter)\n   Requests information from the LMS.\n\n   Parameter: parameter (string, name of the SCORM data model element)\n   Returns:   string (the value of the specified data model element)\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.data.get = function(parameter){\n\n    var value = null,\n        scorm = pipwerks.SCORM,\n        trace = pipwerks.UTILS.trace,\n        debug = scorm.debug,\n        traceMsgPrefix = \"SCORM.data.get(\" +parameter +\") \";\n\n    if(scorm.connection.isActive){\n\n        var API = scorm.API.getHandle(),\n            errorCode = 0;\n\n          if(API){\n\n            switch(scorm.version){\n                case \"1.2\" : value = API.LMSGetValue(parameter); break;\n                case \"2004\": value = API.GetValue(parameter); break;\n            }\n\n            errorCode = debug.getCode();\n\n            //GetValue returns an empty string on errors\n            //If value is an empty string, check errorCode to make sure there are no errors\n            if(value !== \"\" || errorCode === 0){\n\n                //GetValue is successful.  \n                //If parameter is lesson_status/completion_status or exit status, let's\n                //grab the value and cache it so we can check it during connection.terminate()\n                switch(parameter){\n\n                    case \"cmi.core.lesson_status\":\n                    case \"cmi.completion_status\" : scorm.data.completionStatus = value; break;\n\n                    case \"cmi.core.exit\":\n                    case \"cmi.exit\"     : scorm.data.exitStatus = value; break;\n\n                }\n\n            } else {\n\n                trace(traceMsgPrefix +\"failed. \\nError code: \" +errorCode +\"\\nError info: \" +debug.getInfo(errorCode));\n\n            }\n\n        } else {\n\n            trace(traceMsgPrefix +\"failed: API is null.\");\n\n        }\n\n    } else {\n\n        trace(traceMsgPrefix +\"failed: API connection is inactive.\");\n\n    }\n\n    trace(traceMsgPrefix +\" value: \" +value);\n\n    return String(value);\n\n};\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.data.set()\n   Tells the LMS to assign the value to the named data model element.\n   Also stores the SCO's completion status in a variable named\n   pipwerks.SCORM.data.completionStatus. This variable is checked whenever\n   pipwerks.SCORM.connection.terminate() is invoked.\n\n   Parameters: parameter (string). The data model element\n               value (string). The value for the data model element\n   Returns:    Boolean\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.data.set = function(parameter, value){\n\n    var success = false,\n        scorm = pipwerks.SCORM,\n        trace = pipwerks.UTILS.trace,\n        makeBoolean = pipwerks.UTILS.StringToBoolean,\n        debug = scorm.debug,\n        traceMsgPrefix = \"SCORM.data.set(\" +parameter +\") \";\n\n\n    if(scorm.connection.isActive){\n\n        var API = scorm.API.getHandle(),\n            errorCode = 0;\n\n        if(API){\n\n            switch(scorm.version){\n                case \"1.2\" : success = makeBoolean(API.LMSSetValue(parameter, value)); break;\n                case \"2004\": success = makeBoolean(API.SetValue(parameter, value)); break;\n            }\n\n            if(success){\n\n                if(parameter === \"cmi.core.lesson_status\" || parameter === \"cmi.completion_status\"){\n\n                    scorm.data.completionStatus = value;\n\n                }\n\n            } else {\n\n                errorCode = debug.getCode();\n\n                trace(traceMsgPrefix +\"failed. \\nError code: \" +errorCode +\". \\nError info: \" +debug.getInfo(errorCode));\n\n            }\n\n        } else {\n\n            trace(traceMsgPrefix +\"failed: API is null.\");\n\n        }\n\n    } else {\n\n        trace(traceMsgPrefix +\"failed: API connection is inactive.\");\n\n    }\n\n    return success;\n\n};\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.data.save()\n   Instructs the LMS to persist all data to this point in the session\n\n   Parameters: None\n   Returns:    Boolean\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.data.save = function(){\n\n    var success = false,\n        scorm = pipwerks.SCORM,\n        trace = pipwerks.UTILS.trace,\n        makeBoolean = pipwerks.UTILS.StringToBoolean,\n        traceMsgPrefix = \"SCORM.data.save failed\";\n\n\n    if(scorm.connection.isActive){\n\n        var API = scorm.API.getHandle();\n\n        if(API){\n\n            switch(scorm.version){\n                case \"1.2\" : success = makeBoolean(API.LMSCommit(\"\")); break;\n                case \"2004\": success = makeBoolean(API.Commit(\"\")); break;\n            }\n\n        } else {\n\n            trace(traceMsgPrefix +\": API is null.\");\n\n        }\n\n    } else {\n\n        trace(traceMsgPrefix +\": API connection is inactive.\");\n\n    }\n\n    return success;\n\n};\n\n\npipwerks.SCORM.status = function (action, status){\n\n    var success = false,\n        scorm = pipwerks.SCORM,\n        trace = pipwerks.UTILS.trace,\n        traceMsgPrefix = \"SCORM.getStatus failed\",\n        cmi = \"\";\n\n    if(action !== null){\n\n        switch(scorm.version){\n            case \"1.2\" : cmi = \"cmi.core.lesson_status\"; break;\n            case \"2004\": cmi = \"cmi.completion_status\"; break;\n        }\n\n        switch(action){\n\n            case \"get\": success = scorm.data.get(cmi); break;\n\n            case \"set\": if(status !== null){\n\n                            success = scorm.data.set(cmi, status);\n\n                        } else {\n\n                            success = false;\n                            trace(traceMsgPrefix +\": status was not specified.\");\n\n                        }\n\n                        break;\n\n            default      : success = false;\n                        trace(traceMsgPrefix +\": no valid action was specified.\");\n\n        }\n\n    } else {\n\n        trace(traceMsgPrefix +\": action was not specified.\");\n\n    }\n\n    return success;\n\n};\n\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.SCORM.debug functions -------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.debug.getCode\n   Requests the error code for the current error state from the LMS\n\n   Parameters: None\n   Returns:    Integer (the last error code).\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.debug.getCode = function(){\n\n    var scorm = pipwerks.SCORM,\n        API = scorm.API.getHandle(),\n        trace = pipwerks.UTILS.trace,\n        code = 0;\n\n    if(API){\n\n        switch(scorm.version){\n            case \"1.2\" : code = parseInt(API.LMSGetLastError(), 10); break;\n            case \"2004\": code = parseInt(API.GetLastError(), 10); break;\n        }\n\n    } else {\n\n        trace(\"SCORM.debug.getCode failed: API is null.\");\n\n    }\n\n    return code;\n\n};\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.debug.getInfo()\n   \"Used by a SCO to request the textual description for the error code\n   specified by the value of [errorCode].\"\n\n   Parameters: errorCode (integer).\n   Returns:    String.\n----------------------------------------------------------------------------- */\n\npipwerks.SCORM.debug.getInfo = function(errorCode){\n\n    var scorm = pipwerks.SCORM,\n        API = scorm.API.getHandle(),\n        trace = pipwerks.UTILS.trace,\n        result = \"\";\n\n\n    if(API){\n\n        switch(scorm.version){\n            case \"1.2\" : result = API.LMSGetErrorString(errorCode.toString()); break;\n            case \"2004\": result = API.GetErrorString(errorCode.toString()); break;\n        }\n\n    } else {\n\n        trace(\"SCORM.debug.getInfo failed: API is null.\");\n\n    }\n\n    return String(result);\n\n};\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.SCORM.debug.getDiagnosticInfo\n   \"Exists for LMS specific use. It allows the LMS to define additional\n   diagnostic information through the API Instance.\"\n\n   Parameters: errorCode (integer).\n   Returns:    String (Additional diagnostic information about the given error code).\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.debug.getDiagnosticInfo = function(errorCode){\n\n    var scorm = pipwerks.SCORM,\n        API = scorm.API.getHandle(),\n        trace = pipwerks.UTILS.trace,\n        result = \"\";\n\n    if(API){\n\n        switch(scorm.version){\n            case \"1.2\" : result = API.LMSGetDiagnostic(errorCode); break;\n            case \"2004\": result = API.GetDiagnostic(errorCode); break;\n        }\n\n    } else {\n\n        trace(\"SCORM.debug.getDiagnosticInfo failed: API is null.\");\n\n    }\n\n    return String(result);\n\n};\n\n\n// ------------------------------------------------------------------------- //\n// --- Shortcuts! ---------------------------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n// Because nobody likes typing verbose code.\n\npipwerks.SCORM.init = pipwerks.SCORM.connection.initialize;\npipwerks.SCORM.get  = pipwerks.SCORM.data.get;\npipwerks.SCORM.set  = pipwerks.SCORM.data.set;\npipwerks.SCORM.save = pipwerks.SCORM.data.save;\npipwerks.SCORM.quit = pipwerks.SCORM.connection.terminate;\n\n\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.UTILS functions -------------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.UTILS.StringToBoolean()\n   Converts 'boolean strings' into actual valid booleans.\n\n   (Most values returned from the API are the strings \"true\" and \"false\".)\n\n   Parameters: String\n   Returns:    Boolean\n---------------------------------------------------------------------------- */\n\npipwerks.UTILS.StringToBoolean = function(value){\n    var t = typeof value;\n    switch(t){\n       //typeof new String(\"true\") === \"object\", so handle objects as string via fall-through. \n       //See https://github.com/pipwerks/scorm-api-wrapper/issues/3\n       case \"object\":  \n       case \"string\": return (/(true|1)/i).test(value);\n       case \"number\": return !!value;\n       case \"boolean\": return value;\n       case \"undefined\": return null;\n       default: return false;\n    }\n};\n\n\n\n/* -------------------------------------------------------------------------\n   pipwerks.UTILS.trace()\n   Displays error messages when in debug mode.\n\n   Parameters: msg (string)\n   Return:     None\n---------------------------------------------------------------------------- */\n\npipwerks.UTILS.trace = function(msg){\n\n     if(pipwerks.debug.isActive){\n\n        if(window.console && window.console.log){\n            window.console.log(msg);\n        } else {\n            //alert(msg);\n        }\n\n     }\n};\n\ndefine(\"extensions/adapt-contrib-spoor/js/scorm/API\", function(){});\n\n","define ('extensions/adapt-contrib-spoor/js/scorm/wrapper',['require'],function(require) {\n\n\t/*\n\t\tIMPORTANT: This wrapper uses the Pipwerks SCORM wrapper and should therefore support both SCORM 1.2 and 2004. Ensure any changes support both versions.\n\t*/\n\n\tvar ScormWrapper = function() {\n\t\t/* configuration */\n\t\tthis.setCompletedWhenFailed = true;// this only applies to SCORM 2004\n\t\t/**\n\t\t * whether to commit each time there's a change to lesson_status or not\n\t\t */\n\t\tthis.commitOnStatusChange = true;\n\t\t/**\n\t\t * how frequently (in minutes) to commit automatically. set to 0 to disable.\n\t\t */\n\t\tthis.timedCommitFrequency = 10;\n\t\t/**\n\t\t * how many times to retry if a commit fails\n\t\t */\n\t\tthis.maxCommitRetries = 5;\n\t\t/**\n\t\t * time (in milliseconds) to wait between retries\n\t\t */\n\t\tthis.commitRetryDelay = 1000;\n\t\t\n\t\t/**\n\t\t * prevents commit from being called if there's already a 'commit retry' pending.\n\t\t */\n\t\tthis.commitRetryPending = false;\n\t\t/**\n\t\t * how many times we've done a 'commit retry'\n\t\t */\n\t\tthis.commitRetries = 0;\n\t\t/**\n\t\t * not currently used - but you could include in an error message to show when data was last saved\n\t\t */\n\t\tthis.lastCommitSuccessTime = null;\n\t\t\n\t\tthis.timedCommitIntervalID = null;\n\t\tthis.retryCommitTimeoutID = null;\n\t\tthis.logOutputWin = null;\n\t\tthis.startTime = null;\n\t\tthis.endTime = null;\n\t\t\n\t\tthis.lmsConnected = false;\n\t\tthis.finishCalled = false;\n\t\t\n\t\tthis.logger = Logger.getInstance();\n\t\tthis.scorm = pipwerks.SCORM;\n\n        \tthis.suppressErrors = false;\n        \n\t\tif (window.__debug)\n\t\t\tthis.showDebugWindow();\n\t};\n\n\t// static\n\tScormWrapper.instance = null;\n\n\t/******************************* public methods *******************************/\n\n\t// static\n\tScormWrapper.getInstance = function() {\n\t\tif (ScormWrapper.instance === null)\n\t\t\tScormWrapper.instance = new ScormWrapper();\n\t\treturn ScormWrapper.instance;\n\t};\n\n\tScormWrapper.prototype.getVersion = function() {\n\t\treturn this.scorm.version;\n\t};\n\n\tScormWrapper.prototype.setVersion = function(value) {\n\t\tthis.scorm.version = value;\n\t\t/**\n\t\t * stop the pipwerks code from setting cmi.core.exit to suspend/logout when targeting SCORM 1.2.\n\t\t * there doesn't seem to be any tangible benefit to doing this in 1.2 and it can actually cause problems with some LMSes\n\t\t * (e.g. setting it to 'logout' apparently causes Plateau to log the user completely out of the LMS!)\n\t\t * It needs to be on for SCORM 2004 though, otherwise the LMS might not restore the suspend_data\n\t\t */\n\t\tthis.scorm.handleExitMode = this.isSCORM2004();\n\t};\n\n\tScormWrapper.prototype.initialize = function() {\n\t\tthis.lmsConnected = this.scorm.init();\n\n\t\tif (this.lmsConnected) {\n\t\t\tthis.startTime = new Date();\n\t\t\t\n\t\t\tthis.initTimedCommit();\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"Course could not connect to the LMS\");\n\t\t}\n\t\t\n\t\treturn this.lmsConnected;\n\t};\n\n\t/**\n\t* allows you to check if this is the user's first ever 'session' of a SCO, even after the lesson_status has been set to 'incomplete'\n\t*/\n\tScormWrapper.prototype.isFirstSession = function() {\n\t\treturn (this.getValue(this.isSCORM2004() ? \"cmi.entry\" :\"cmi.core.entry\") === \"ab-initio\");\n\t};\n\n\tScormWrapper.prototype.setIncomplete = function() {\n\t\tthis.setValue(this.isSCORM2004() ? \"cmi.completion_status\" : \"cmi.core.lesson_status\", \"incomplete\");\n\n\t\tif(this.commitOnStatusChange) this.commit();\n\t};\n\n\tScormWrapper.prototype.setCompleted = function() {\n\t\tthis.setValue(this.isSCORM2004() ? \"cmi.completion_status\" : \"cmi.core.lesson_status\", \"completed\");\n\t\t\n\t\tif(this.commitOnStatusChange) this.commit();\n\t};\n\n\tScormWrapper.prototype.setPassed = function() {\n\t\tif (this.isSCORM2004()) {\n\t\t\tthis.setValue(\"cmi.completion_status\", \"completed\");\n\t\t\tthis.setValue(\"cmi.success_status\", \"passed\");\n\t\t}\n\t\telse {\n\t\t\tthis.setValue(\"cmi.core.lesson_status\", \"passed\");\n\t\t}\n\n\t\tif(this.commitOnStatusChange) this.commit();\n\t};\n\n\tScormWrapper.prototype.setFailed = function() {\n\t\tif (this.isSCORM2004()) {\n\t\t\tthis.setValue(\"cmi.success_status\", \"failed\");\n\t\t\t\n\t\t\tif(this.setCompletedWhenFailed)\n\t\t\t\tthis.setValue(\"cmi.completion_status\", \"completed\");\n\t\t}\n\t\telse {\n\t\t\tthis.setValue(\"cmi.core.lesson_status\", \"failed\");\n\t\t}\n\n\t\t\tif(this.commitOnStatusChange) this.commit();\n\t};\n\n\tScormWrapper.prototype.getStatus = function() {\n\t\tvar status = this.getValue(this.isSCORM2004() ? \"cmi.completion_status\" : \"cmi.core.lesson_status\");\n\n\t\tswitch(status.toLowerCase()) {// workaround for some LMSes (e.g. Arena) not adhering to the all-lowercase rule\n\t\t\tcase \"passed\":\n\t\t\tcase \"completed\":\n\t\t\tcase \"incomplete\":\n\t\t\tcase \"failed\":\n\t\t\tcase \"browsed\":\n\t\t\tcase \"not attempted\":\n\t\t\tcase \"not_attempted\":// mentioned in SCORM 2004 docs but not sure it ever gets used\n\t\t\tcase \"unknown\": //the SCORM 2004 version if not attempted\n\t\t\t\treturn status;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.handleError(\"ScormWrapper::getStatus: invalid lesson status '\" + status + \"' received from LMS\");\n\t\t\t\treturn null;\n\t\t}\n\t};\n\n\tScormWrapper.prototype.setStatus = function(status) {\n\t\tswitch (status.toLowerCase()){\n        case \"incomplete\":\n          this.setIncomplete();\n          break;\n        case \"completed\":\n          this.setCompleted();\n          break;\n        case \"passed\":\n          this.setPassed();\n          break;\n        case \"failed\":\n          this.setFailed();\n          break;\n        default:\n          this.handleError(\"ScormWrapper::setStatus: the status '\" + status + \"' is not supported.\");\n          break;\n      }\n\t}\n\n\tScormWrapper.prototype.getScore = function() {\n\t\treturn this.getValue(this.isSCORM2004() ? \"cmi.score.raw\" : \"cmi.core.score.raw\");\n\t};\n\n\tScormWrapper.prototype.setScore = function(_score, _minScore, _maxScore) {\n\t\tif (this.isSCORM2004()) {\n\t\t\tthis.setValue(\"cmi.score.raw\", _score) && this.setValue(\"cmi.score.min\", _minScore) && this.setValue(\"cmi.score.max\", _maxScore) && this.setValue(\"cmi.score.scaled\", _score / 100);\n\t\t}\n\t\telse {\n\t\t\tthis.setValue(\"cmi.core.score.raw\", _score);\n\n\t\t\tif(this.isSupported(\"cmi.core.score.min\")) this.setValue(\"cmi.core.score.min\", _minScore);\n\n\t\t\tif(this.isSupported(\"cmi.core.score.max\")) this.setValue(\"cmi.core.score.max\", _maxScore);\n\t\t}\n\t};\n\n\tScormWrapper.prototype.getLessonLocation = function() {\n\t\treturn this.getValue(this.isSCORM2004() ? \"cmi.location\" : \"cmi.core.lesson_location\");\n\t};\n\n\tScormWrapper.prototype.setLessonLocation = function(_location) {\n\t\tthis.setValue(this.isSCORM2004() ? \"cmi.location\" : \"cmi.core.lesson_location\", _location);\n\t};\n\n\tScormWrapper.prototype.getSuspendData = function() {\n\t\treturn this.getValue(\"cmi.suspend_data\");\n\t};\n\n\tScormWrapper.prototype.setSuspendData = function(_data) {\n\t\tthis.setValue(\"cmi.suspend_data\", _data);\n\t};\n\n\tScormWrapper.prototype.getStudentName = function() {\n\t\treturn this.getValue(this.isSCORM2004() ? \"cmi.learner_name\" : \"cmi.core.student_name\");\n\t};\n\n\tScormWrapper.prototype.getStudentId = function(){\n\t\treturn this.getValue(this.isSCORM2004() ? \"cmi.learner_id\":\"cmi.core.student_id\");\n\t};\n\n\tScormWrapper.prototype.commit = function() {\n\t\tthis.logger.debug(\"ScormWrapper::commit\");\n\t\t\n\t\tif (this.lmsConnected) {\n\t\t\tif (this.commitRetryPending) {\n\t\t\t\tthis.logger.debug(\"ScormWrapper::commit: skipping this commit call as one is already pending.\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (this.scorm.save()) {\n\t\t\t\t\tthis.commitRetries = 0;\n\t\t\t\t\tthis.lastCommitSuccessTime = new Date();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.commitRetries < this.maxCommitRetries && !this.finishCalled) {\n\t\t\t\t\t\tthis.commitRetries++;\n\t\t\t\t\t\tthis.initRetryCommit();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar _errorCode = this.scorm.debug.getCode();\n\n\t\t\t\t\t\tvar _errorMsg = \"Course could not commit data to the LMS\";\n\t\t\t\t\t\t_errorMsg += \"\\nError \" + _errorCode + \": \" + this.scorm.debug.getInfo(_errorCode);\n\t\t\t\t\t\t_errorMsg += \"\\nLMS Error Info: \" + this.scorm.debug.getDiagnosticInfo(_errorCode);\n\n\t\t\t\t\t\tthis.handleError(_errorMsg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"Course is not connected to the LMS\");\n\t\t}\n\t};\n\n\tScormWrapper.prototype.finish = function() {\n\t\tthis.logger.debug(\"ScormWrapper::finish\");\n\t\t\n\t\tif (this.lmsConnected && !this.finishCalled) {\n\t\t\tthis.finishCalled = true;\n\t\t\t\n\t\t\tif(this.timedCommitIntervalID != null) {\n\t\t\t\twindow.clearInterval(this.timedCommitIntervalID);\n\t\t\t}\n\t\t\t\n\t\t\tif(this.commitRetryPending) {\n\t\t\t\twindow.clearTimeout(this.retryCommitTimeoutID);\n\t\t\t\tthis.commitRetryPending = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.logOutputWin && !this.logOutputWin.closed) {\n\t\t\t\tthis.logOutputWin.close();\n\t\t\t}\n\t\t\t\n\t\t\tthis.endTime = new Date();\n\t\t\t\n\t\t\tif (this.isSCORM2004()) {\n\t\t\t\tthis.scorm.set(\"cmi.session_time\", this.convertMilliSecondsToSCORM2004Time(this.endTime.getTime() - this.startTime.getTime()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.scorm.set(\"cmi.core.session_time\", this.convertMilliSecondsToSCORMTime(this.endTime.getTime() - this.startTime.getTime()));\n\t\t\t\tthis.scorm.set(\"cmi.core.exit\", \"\");\n\t\t\t}\n\t\t\t\n\t\t\t// api no longer available from this point\n\t\t\tthis.lmsConnected = false;\n\t\t\t\n\t\t\tif (!this.scorm.quit()) {\n\t\t\t\tthis.handleError(\"Course could not finish\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"Course is not connected to the LMS\");\n\t\t}\n\t};\n\n\tScormWrapper.prototype.recordInteraction = function(strID, strResponse, strCorrect, strLatency, scormInteractionType) {\n\t\tif(this.isSupported(\"cmi.interactions._count\")) {\n\t\t\tswitch(scormInteractionType) {\n\t\t\t\tcase \"choice\":\n\t\t\t\t\tvar responseIdentifiers = [];\n\t\t\t\t\tvar answers = strResponse.split(\"#\");\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0, count = answers.length; i < count; i++) {\n\t\t\t\t\t\tresponseIdentifiers.push(new ResponseIdentifier(answers[i], answers[i]));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.recordMultipleChoiceInteraction(strID, responseIdentifiers, strCorrect, null, null, null, strLatency, null);\n\t\t\t\tbreak;\n\n\t\t\t\tcase \"matching\":\n\t\t\t\t\tvar matchingResponses = [];\n\t\t\t\t\tvar sourceTargetPairs = strResponse.split(\"#\");\n\t\t\t\t\tvar sourceTarget = null;\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0, count = sourceTargetPairs.length; i < count; i++) {\n\t\t\t\t\t\tsourceTarget = sourceTargetPairs[i].split(\".\");\n\t\t\t\t\t\tmatchingResponses.push(new MatchingResponse(sourceTarget[0], sourceTarget[1]));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.recordMatchingInteraction(strID, matchingResponses, strCorrect, null, null, null, strLatency, null);\n\t\t\t\tbreak;\n\n\t\t\t\tcase \"numeric\":\n\t\t\t\t\tthis.recordNumericInteraction(strID, strResponse, strCorrect, null, null, null, strLatency, null);\n\t\t\t\tbreak;\n\n\t\t\t\tcase \"fill-in\":\n\t\t\t\t\tthis.recordFillInInteraction(strID, strResponse, strCorrect, null, null, null, strLatency, null);\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error(\"ScormWrapper.recordInteraction: unknown interaction type of '\" + scormInteractionType + \"' encountered...\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.logger.info(\"ScormWrapper::recordInteraction: cmi.interactions are not supported by this LMS...\");\n\t\t}\n\t}\n\n\t/****************************** private methods ******************************/\n\tScormWrapper.prototype.getValue = function(_property) {\n\t\tthis.logger.debug(\"ScormWrapper::getValue: _property=\" + _property);\n\n\t\tif(this.finishCalled) {\n\t\t\tthis.logger.debug(\"ScormWrapper::getValue: ignoring request as 'finish' has been called\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (this.lmsConnected) {\n\t\t\tvar _value = this.scorm.get(_property);\n\t\t\tvar _errorCode = this.scorm.debug.getCode();\n\t\t\tvar _errorMsg = \"\";\n\t\t\t\n\t\t\tif (_errorCode !== 0) {\n\t\t\t\tif (_errorCode === 403) {\n\t\t\t\t\tthis.logger.warn(\"ScormWrapper::getValue: data model element not initialized\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_errorMsg += \"Course could not get \" + _property;\n\t\t\t\t\t_errorMsg += \"\\nError Info: \" + this.scorm.debug.getInfo(_errorCode);\n\t\t\t\t\t_errorMsg += \"\\nLMS Error Info: \" + this.scorm.debug.getDiagnosticInfo(_errorCode);\n\t\t\t\t\t\n\t\t\t\t\tthis.handleError(_errorMsg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.logger.debug(\"ScormWrapper::getValue: returning \" + _value);\n\t\t\treturn _value + \"\";\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"Course is not connected to the LMS\");\n\t\t}\n\t};\n\n\tScormWrapper.prototype.setValue = function(_property, _value) {\n\t\tthis.logger.debug(\"ScormWrapper::setValue: _property=\" + _property + \" _value=\" + _value);\n\n\t\tif(this.finishCalled)\t{\n\t\t\tthis.logger.debug(\"ScormWrapper::setValue: ignoring request as 'finish' has been called\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (this.lmsConnected) {\n\t\t\tvar _success = this.scorm.set(_property, _value);\n\t\t\tvar _errorCode = this.scorm.debug.getCode();\n\t\t\tvar _errorMsg = \"\";\n\t\t\t\n\t\t\tif (!_success) {\n\t\t\t/*\n\t\t\t* Some LMSes have an annoying tendency to return false from a set call even when it actually worked fine.\n\t\t\t* So, we should throw an error _only_ if there was a valid error code...\n\t\t\t*/\n\t\t\t\tif(_errorCode !== 0) {\n\t\t\t\t\t_errorMsg += \"Course could not set \" + _property + \" to \" + _value;\n\t\t\t\t\t_errorMsg += \"\\nError Info: \" + this.scorm.debug.getInfo(_errorCode);\n\t\t\t\t\t_errorMsg += \"\\nLMS Error Info: \" + this.scorm.debug.getDiagnosticInfo(_errorCode);\n\t\t\t\t\t\n\t\t\t\t\tthis.handleError(_errorMsg);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.logger.warn(\"ScormWrapper::setValue: LMS reported that the 'set' call failed but then said there was no error!\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn _success;\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"Course is not connected to the LMS\");\n\t\t}\n\t};\n\n\t/**\n\t* used for checking any data field that is not 'LMS Mandatory' to see whether the LMS we're running on supports it or not.\n\t* Note that the way this check is being performed means it wouldn't work for any element that is\n\t* 'write only', but so far we've not had a requirement to check for any optional elements that are.\n\t*/\n\tScormWrapper.prototype.isSupported = function(_property) {\n\t\tthis.logger.debug(\"ScormWrapper::isSupported: _property=\" + _property);\n\n\t\tif(this.finishCalled) {\n\t\t\tthis.logger.debug(\"ScormWrapper::isSupported: ignoring request as 'finish' has been called\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (this.lmsConnected) {\n\t\t\tvar _value = this.scorm.get(_property);\n\t\t\tvar _errorCode = this.scorm.debug.getCode();\n\t\t\t\n\t\t\treturn (_errorCode === 401 ? false : true);\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"Course is not connected to the LMS\");\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tScormWrapper.prototype.initTimedCommit = function() {\n\t\tthis.logger.debug(\"ScormWrapper::initTimedCommit\");\n\t\t\n\t\tif(this.timedCommitFrequency > 0) {\n\t\t\tvar delay = this.timedCommitFrequency * (60 * 1000);\n\t\t\tthis.timedCommitIntervalID = window.setInterval(_.bind(this.commit, this), delay);\n\t\t}\n\t};\n\n\tScormWrapper.prototype.initRetryCommit = function() {\n\t\tthis.logger.debug(\"ScormWrapper::initRetryCommit \" + this.commitRetries + \" out of \" + this.maxCommitRetries);\n\t\t\n\t\tthis.commitRetryPending = true;// stop anything else from calling commit until this is done\n\t\t\n\t\tthis.retryCommitTimeoutID = window.setTimeout(_.bind(this.doRetryCommit, this), this.commitRetryDelay);\n\t};\n\n\tScormWrapper.prototype.doRetryCommit = function() {\n\t\tthis.logger.debug(\"ScormWrapper::doRetryCommit\");\n\n\t\tthis.commitRetryPending = false;\n\n\t\tthis.commit();\n\t};\n\n\tScormWrapper.prototype.handleError = function(_msg) {\n\t\tthis.logger.error(_msg);\n\t\t\n\t\tif (!this.suppressErrors && (!this.logOutputWin || this.logOutputWin.closed) && confirm(\"An error has occured:\\n\\n\" + _msg + \"\\n\\nPress 'OK' to view debug information to send to technical support.\"))\n\t\t\tthis.showDebugWindow();\n\t};\n\n\tScormWrapper.prototype.createValidIdentifier = function(str)\n\t{\n\t\tstr = this.trim(new String(str));\n\n\t\tif (_.indexOf(str.toLowerCase(), \"urn:\") === 0) {\n\t\t\tstr = str.substr(4);\n\t\t}\n\t\t\n\t\t// URNs may only contain the following characters: letters, numbers - ( ) + . : = @ ; $ _ ! * ' %\n\t\t// if anything else is found, replace it with _\n\t\tstr = str.replace(/[^\\w\\-\\(\\)\\+\\.\\:\\=\\@\\;\\$\\_\\!\\*\\'\\%]/g, \"_\");\n\n\t\treturn str;\n\t};\n\n\tScormWrapper.prototype.createResponseIdentifier = function(strShort, strLong) {\n\t\t\n\t\tif (strShort.length != 1 || strShort.search(/\\w/) < 0) {\n\t\t\tstrShort = \"\";\n\t\t}\n\t\telse {\n\t\t\tstrShort = strShort.toLowerCase();\n\t\t}\n\t\t\n\t\tstrLong = this.createValidIdentifier(strLong);\n\t\t\n\t\treturn new ResponseIdentifier(strShort, strLong);\n\t};\n\n\tScormWrapper.prototype.recordInteraction12 = function(strID, strResponse, bCorrect, strCorrectResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, scormInteractionType, strAlternateResponse, strAlternateCorrectResponse) {\n\t\tvar bResult;\n\t\tvar bTempResult;\n\t\tvar interactionIndex;\n\t\tvar strResult;\n\t\t\n\t\t// in SCORM 1.2, add a new interaction rather than updating an old one, because some LMS vendors have misinterpreted the \"write only\" rule regarding interactions to mean \"write once\"\n\t\tinteractionIndex = this.getValue(\"cmi.interactions._count\");\n\t\t\n\t\tif (interactionIndex === \"\") {\n\t\t\tinteractionIndex = 0;\n\t\t}\n\t\t\n\t\tif (bCorrect === true || bCorrect === \"true\" || bCorrect === \"correct\") {\n\t\t\tstrResult = \"correct\";\n\t\t}\n\t\telse if (bCorrect === false || bCorrect === \"false\" || bCorrect === \"wrong\") {\n\t\t\tstrResult = \"wrong\";\n\t\t}\n\t\telse if (bCorrect === \"unanticipated\") {\n\t\t\tstrResult = \"unanticipated\";\n\t\t}\n\t\telse if (bCorrect === \"neutral\") {\n\t\t\tstrResult = \"neutral\";\n\t\t}\n\n\t\tvar prefix = \"cmi.interactions.\" + interactionIndex;\n\t\t\n\t\tbResult = this.setValue(prefix + \".id\", strID);\n\t\tbResult = bResult && this.setValue(prefix + \".type\", scormInteractionType);\n\t\t\n\t\tbTempResult = this.setValue(prefix + \".student_response\", strResponse);\n\t\t\n\t\tif (bTempResult === false) {\n\t\t\tbTempResult = this.setValue(prefix + \".student_response\", strAlternateResponse);\n\t\t}\n\t\t\n\t\tbResult = bResult && bTempResult;\n\t\t\n\t\tif (!_.isEmpty(strCorrectResponse)) {\n\t\t\tbTempResult = this.setValue(prefix + \".correct_responses.0.pattern\", strCorrectResponse);\n\t\t\tif (bTempResult === false) {\n\t\t\t\tbTempResult = this.setValue(prefix + \".correct_responses.0.pattern\", strAlternateCorrectResponse);\n\t\t\t}\n\t\t\t\n\t\t\tbResult = bResult && bTempResult;\n\t\t}\n\n\t\tif (!_.isEmpty(strResult)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".result\", strResult);\n\t\t}\n\t\t\n\t\t// ignore the description parameter in SCORM 1.2, there is nothing we can do with it\n\t\t\n\t\tif (!_.isEmpty(intWeighting)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".weighting\", intWeighting);\n\t\t}\n\n\t\tif (!_.isEmpty(intLatency)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".latency\", this.convertMilliSecondsToSCORMTime(intLatency));\n\t\t}\n\t\t\n\t\tif (!_.isEmpty(strLearningObjectiveID)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".objectives.0.id\", strLearningObjectiveID);\n\t\t}\n\t\t\n\t\tbResult = bResult && this.setValue(prefix + \".time\", this.convertDateToCMITime(dtmTime));\n\t\t\n\t\treturn bResult;\n\t};\n\n\tScormWrapper.prototype.recordInteraction2004 = function(strID, strResponse, bCorrect, strCorrectResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, scormInteractionType) {\t\n\t\tvar bResult;\n\t\tvar interactionIndex;\n\t\tvar strResult;\n\t\t\n\t\tbCorrect = new String(bCorrect);\n\t\t\n\t\tinteractionIndex = this.getValue(\"cmi.interactions._count\");\n\t\t\n\t\tif (interactionIndex === \"\") {\n\t\t\tinteractionIndex = 0;\n\t\t}\n\t\t\n\t\tif (bCorrect === true || bCorrect === \"true\" || bCorrect === \"correct\") {\n\t\t\tstrResult = \"correct\";\n\t\t}\n\t\telse if (bCorrect === false || bCorrect == \"false\" || bCorrect === \"wrong\") {\n\t\t\tstrResult = \"incorrect\";\n\t\t}\n\t\telse if (bCorrect === \"unanticipated\") {\n\t\t\tstrResult = \"unanticipated\";\n\t\t}\n\t\telse if (bCorrect === \"neutral\") {\n\t\t\tstrResult = \"neutral\";\n\t\t}\n\t\telse {\n\t\t\tstrResult = \"\";\n\t\t}\n\t\t\n\t\tstrID = this.createValidIdentifier(strID);\n\n\t\tvar prefix = \"cmi.interactions.\" + interactionIndex;\n\t\t\n\t\tbResult = this.setValue(prefix + \".id\", strID);\n\t\tbResult = bResult && this.setValue(prefix + \".type\", scormInteractionType);\n\t\tbResult = bResult && this.setValue(prefix + \".learner_response\", strResponse);\n\t\t\n\t\tif (!_.isEmpty(strResult)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".result\", strResult);\n\t\t}\n\t\t\n\t\tif (!_.isEmpty(strCorrectResponse)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".correct_responses.0.pattern\", strCorrectResponse);\n\t\t}\n\t\t\n\t\tif (!_.isEmpty(strDescription)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".description\", strDescription);\n\t\t}\n\t\t\n\t\t// ignore the description parameter in SCORM 1.2, there is nothing we can do with it\n\t\t\n\t\tif (!_.isEmpty(intWeighting)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".weighting\", intWeighting);\n\t\t}\n\n\t\tif (!_.isEmpty(intLatency)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".latency\", this.convertMilliSecondsToSCORM2004Time(intLatency));\n\t\t}\n\t\t\n\t\tif (!_.isEmpty(strLearningObjectiveID)) {\n\t\t\tbResult = bResult && this.setValue(prefix + \".objectives.0.id\", strLearningObjectiveID);\n\t\t}\n\t\t\n\t\tbResult = bResult && this.setValue(prefix + \".timestamp\", this.convertDateToISO8601Timestamp(dtmTime));\n\t\t\n\t\treturn bResult;\n\t};\n\n\tScormWrapper.prototype.recordMultipleChoiceInteraction = function(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID) {\n\t\tvar _responseArray = null;\n\t\tvar _correctResponseArray = null;\n\t\t\n\t\tif (response.constructor == String) {\n\t\t\t_responseArray = [this.createResponseIdentifier(response, response)];\n\t\t}\n\t\telse if (response.constructor == ResponseIdentifier) {\n\t\t\t_responseArray = [response];\n\t\t}\n\t\telse if (response.constructor == Array || response.constructor.toString().search(\"Array\") > 0) {\n\t\t\t_responseArray = response;\n\t\t}\n\t\telse if (window.console && response.constructor.toString() == \"(Internal Function)\" && response.length > 0) {\n\t\t\t_responseArray = response;\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"ScormWrapper::recordMultipleChoiceInteraction: response is not in the correct format\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!_.isEmpty(correctResponse)) {\n\t\t\tif (correctResponse.constructor == String) {\n\t\t\t\t_correctResponseArray = [this.createResponseIdentifier(correctResponse, correctResponse)];\n\t\t\t}\n\t\t\telse if (correctResponse.constructor == ResponseIdentifier) {\n\t\t\t\t_correctResponseArray = [correctResponse];\n\t\t\t}\n\t\t\telse if (correctResponse.constructor == Array || correctResponse.constructor.toString().search(\"Array\") > 0) {\n\t\t\t\t_correctResponseArray = correctResponse;\n\t\t\t}\n\t\t\telse if (window.console && correctResponse.constructor.toString() == \"(Internal Function)\" && correctResponse.length > 0) {\n\t\t\t\t_correctResponseArray = correctResponse;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handleError(\"ScormWrapper::recordMultipleChoiceInteraction: correct response is not in the correct format\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_correctResponseArray = [];\n\t\t}\n\t\t\n\t\tvar dtmTime = new Date();\n\t\t\n\t\tvar strResponse = \"\";\n\t\tvar strResponseLong = \"\";\n\t\t\n\t\tvar strCorrectResponse = \"\";\n\t\tvar strCorrectResponseLong = \"\";\n\t\t\n\t\tfor (var i = 0; i < _responseArray.length; i++)\t{\n\t\t\tif (strResponse.length > 0) {strResponse += this.isSCORM2004() ? \"[,]\" : \",\";}\n\t\t\tif (strResponseLong.length > 0) {strResponseLong += \",\";}\n\t\t\t\n\t\t\tstrResponse += this.isSCORM2004() ? _responseArray[i].Long : _responseArray[i].Short;\n\t\t\tstrResponseLong += _responseArray[i].Long;\n\t\t}\n\n\t\tfor (var i = 0; i < _correctResponseArray.length; i++)\t{\n\t\t\tif (strCorrectResponse.length > 0) {strCorrectResponse += this.isSCORM2004() ? \"[,]\" : \",\";}\n\t\t\tif (strCorrectResponseLong.length > 0) {strCorrectResponseLong += \",\";}\n\t\t\t\n\t\t\tstrCorrectResponse += this.isSCORM2004() ? _correctResponseArray[i].Long : _correctResponseArray[i].Short;\n\t\t\tstrCorrectResponseLong += _correctResponseArray[i].Long;\n\t\t}\n\t\t\n\t\tif (this.isSCORM2004())\n\t\t\treturn this.recordInteraction2004(strID, strResponse, blnCorrect, strCorrectResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"choice\");\n\t\t\n\t\treturn this.recordInteraction12(strID, strResponseLong, blnCorrect, strCorrectResponseLong, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"choice\",  strResponse, strCorrectResponse);\n\t};\n\n\tScormWrapper.prototype.recordMatchingInteraction = function(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID) {\n\t\tvar _responseArray = null;\n\t\tvar _correctResponseArray = null;\n\t\t\n\t\tif (response.constructor == MatchingResponse) {\n\t\t\t_responseArray = [response];\n\t\t}\n\t\telse if (response.constructor == Array || response.constructor.toString().search(\"Array\") > 0) {\n\t\t\t_responseArray = response;\n\t\t}\n\t\telse if (window.console && response.constructor.toString() == \"(Internal Function)\" && response.length > 0) {\n\t\t\t_responseArray = response;\n\t\t}\n\t\telse {\n\t\t\tthis.handleError(\"ScormWrapper::recordMatchingInteraction: response is not in the correct format\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!_.isEmpty(correctResponse)) {\n\t\t\tif (correctResponse.constructor == MatchingResponse) {\n\t\t\t\t_correctResponseArray = [correctResponse];\n\t\t\t}\n\t\t\telse if (correctResponse.constructor == Array || correctResponse.constructor.toString().search(\"Array\") > 0) {\n\t\t\t\t_correctResponseArray = correctResponse;\n\t\t\t}\n\t\t\telse if (window.console && correctResponse.constructor.toString() == \"(Internal Function)\" && correctResponse.length > 0)\t{\n\t\t\t\t_correctResponseArray = correctResponse;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.handleError(\"ScormWrapper::recordMatchingInteraction: correct response is not in the correct format\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_correctResponseArray = [];\n\t\t}\n\t\t\n\t\tvar dtmTime = new Date();\n\t\t\n\t\tvar strResponse = \"\";\n\t\tvar strResponseLong = \"\";\n\t\t\n\t\tvar strCorrectResponse = \"\";\n\t\tvar strCorrectResponseLong = \"\";\n\t\t\n\t\tfor (var i = 0; i < _responseArray.length; i++) {\n\t\t\tif (strResponse.length > 0) {strResponse += \",\";}\n\t\t\tif (strResponseLong.length > 0) {strResponseLong += this.isSCORM2004() ? \"[,]\" : \",\";}\n\t\t\t\n\t\t\tstrResponse += _responseArray[i].Source.Short + \".\" + _responseArray[i].Target.Short;\n\t\t\tstrResponseLong += _responseArray[i].Source.Long + (this.isSCORM2004() ? \"[.]\" : \".\") + _responseArray[i].Target.Long;\n\t\t}\n\n\t\tfor (var i = 0; i < _correctResponseArray.length; i++) {\n\t\t\tif (strCorrectResponse.length > 0) {strCorrectResponse += \",\";}\n\t\t\tif (strCorrectResponseLong.length > 0) {strCorrectResponseLong += this.isSCORM2004() ? \"[,]\" : \",\";}\n\t\t\t\n\t\t\tstrCorrectResponse += _correctResponseArray[i].Source.Short + \".\" + _correctResponseArray[i].Target.Short;\n\t\t\tstrCorrectResponseLong += _correctResponseArray[i].Source.Long + (this.isSCORM2004() ? \"[.]\" : \".\") + _correctResponseArray[i].Target.Long;\n\t\t}\n\t\t\n\t\tif (this.isSCORM2004())\n\t\t\treturn this.recordInteraction2004(strID, strResponseLong, blnCorrect, strCorrectResponseLong, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"matching\");\n\t\t\n\t\treturn this.recordInteraction12(strID, strResponseLong, blnCorrect, strCorrectResponseLong, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"matching\", strResponse, strCorrectResponse);\n\t};\n\n\tScormWrapper.prototype.recordNumericInteraction = function(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID) {\n\t\tvar dtmTime = new Date();\n\n\t\tif (this.isSCORM2004())\n\t\t\treturn this.recordInteraction2004(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"numeric\");\n\t\t\n\t\treturn this.recordInteraction12(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"numeric\", response, correctResponse);\n\t};\n\n\tScormWrapper.prototype.recordFillInInteraction = function(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID) {\n\t\tvar dtmTime = new Date();\n\n\t\tvar max_len = this.isSCORM2004() ? 250 : 255;\n\n\t\tif(response.length > max_len) {\n\t\t\tresponse = response.substr(0,max_len);\n\n\t\t\tthis.logger.warn(\"ScormWrapper::recordFillInInteraction: response data for \" + strID + \" is longer than the maximum allowed length of \" + max_len + \" characters; data will be truncated to avoid an error.\");\n\t\t}\n\n\t\tif (this.isSCORM2004())\n\t\t\treturn this.recordInteraction2004(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"fill-in\");\n\t\t\n\t\treturn this.recordInteraction12(strID, response, blnCorrect, correctResponse, strDescription, intWeighting, intLatency, strLearningObjectiveID, dtmTime, \"fill-in\", response, correctResponse);\n\t};\n\n\tScormWrapper.prototype.showDebugWindow = function() {\n\t\t\n\t\tif (this.logOutputWin && !this.logOutputWin.closed) {\n\t\t\tthis.logOutputWin.close();\n\t\t}\n\t\t\n\t\tthis.logOutputWin = window.open(\"log_output.html\", \"Log\", \"width=600,height=300,status=no,scrollbars=yes,resize=yes,menubar=yes,toolbar=yes,location=yes,top=0,left=0\");\n\t\t\n\t\tif (this.logOutputWin)\n\t\t\tthis.logOutputWin.focus();\n\t\t\n\t\treturn;\n\t};\n\n\tScormWrapper.prototype.convertMilliSecondsToSCORMTime = function(value) {\n\t\tvar h;\n\t\tvar m;\n\t\tvar s;\n\t\tvar ms;\n\t\tvar cs;\n\t\tvar CMITimeSpan;\n\t\t\n\t\tms = value % 1000;\n\n\t\ts = ((value - ms) / 1000) % 60;\n\n\t\tm = ((value - ms - (s * 1000)) / 60000) % 60;\n\n\t\th = (value - ms - (s * 1000) - (m * 60000)) / 3600000;\n\t\t\n\t\tif (h === 10000)\t{\n\t\t\th = 9999;\n\t\t\t\n\t\t\tm = (value - (h * 3600000)) / 60000;\n\t\t\tif (m === 100)\t{\n\t\t\t\tm = 99;\n\t\t\t}\n\t\t\tm = Math.floor(m);\n\t\t\t\n\t\t\ts = (value - (h * 3600000) - (m * 60000)) / 1000;\n\t\t\tif (s === 100)\t{\n\t\t\t\ts = 99;\n\t\t\t}\n\t\t\ts = Math.floor(s);\n\t\t\t\n\t\t\tms = (value - (h * 3600000) - (m * 60000) - (s * 1000));\n\t\t}\n\n\t\tcs = Math.floor(ms / 10);\n\n\t\tCMITimeSpan = this.zeroPad(h, 4) + \":\" + this.zeroPad(m, 2) + \":\" +\tthis.zeroPad(s, 2);\n\t\tCMITimeSpan += \".\" + cs;\n\t\t\n\t\tif (h > 9999) {\n\t\t\tCMITimeSpan = \"9999:99:99\";\n\t\t\t\n\t\t\tCMITimeSpan += \".99\";\n\t\t}\n\t\t\n\t\treturn CMITimeSpan;\n\t};\n\n\tScormWrapper.prototype.convertDateToCMITime = function(_value) {\n\t\tvar h;\n\t\tvar m;\n\t\tvar s;\n\t\t\n\t\tvar dtmDate = new Date(_value);\n\t\t\n\t\th = dtmDate.getHours();\n\t\tm = dtmDate.getMinutes();\n\t\ts = dtmDate.getSeconds();\n\t\t\n\t\treturn this.zeroPad(h, 2) + \":\" + this.zeroPad(m, 2) + \":\" + this.zeroPad(s, 2);\n\t};\n\n\tScormWrapper.prototype.convertMilliSecondsToSCORM2004Time = function(_value) {\n\t\tvar str = \"\";\n\t\tvar cs;\n\t\tvar s;\n\t\tvar m;\n\t\tvar h;\n\t\tvar d;\n\t\tvar mo; // assumed to be an \"average\" month (a leap year every 4 years) = ((365*4) + 1) / 48 = 30.4375 days per month\n\t\tvar y;\n\t\t\n\t\tvar HUNDREDTHS_PER_SECOND = 100;\n\t\tvar HUNDREDTHS_PER_MINUTE = HUNDREDTHS_PER_SECOND * 60;\n\t\tvar HUNDREDTHS_PER_HOUR   = HUNDREDTHS_PER_MINUTE * 60;\n\t\tvar HUNDREDTHS_PER_DAY    = HUNDREDTHS_PER_HOUR * 24;\n\t\tvar HUNDREDTHS_PER_MONTH  = HUNDREDTHS_PER_DAY * (((365 * 4) + 1) / 48);\n\t\tvar HUNDREDTHS_PER_YEAR   = HUNDREDTHS_PER_MONTH * 12;\n\t\t\n\t\tcs = Math.floor(_value / 10);\n\t\t\n\t\ty = Math.floor(cs / HUNDREDTHS_PER_YEAR);\n\t\tcs -= (y * HUNDREDTHS_PER_YEAR);\n\t\t\n\t\tmo = Math.floor(cs / HUNDREDTHS_PER_MONTH);\n\t\tcs -= (mo * HUNDREDTHS_PER_MONTH);\n\t\t\n\t\td = Math.floor(cs / HUNDREDTHS_PER_DAY);\n\t\tcs -= (d * HUNDREDTHS_PER_DAY);\n\t\t\n\t\th = Math.floor(cs / HUNDREDTHS_PER_HOUR);\n\t\tcs -= (h * HUNDREDTHS_PER_HOUR);\n\t\t\n\t\tm = Math.floor(cs / HUNDREDTHS_PER_MINUTE);\n\t\tcs -= (m * HUNDREDTHS_PER_MINUTE);\n\t\t\n\t\ts = Math.floor(cs / HUNDREDTHS_PER_SECOND);\n\t\tcs -= (s * HUNDREDTHS_PER_SECOND);\n\t\t\n\t\tif (y > 0)\n\t\t\tstr += y + \"Y\";\n\t\tif (mo > 0)\n\t\t\tstr += mo + \"M\";\n\t\tif (d > 0)\n\t\t\tstr += d + \"D\";\n\t\t\n\t\t// check to see if we have any time before adding the \"T\"\n\t\tif ((cs + s + m + h) > 0 ) {\n\t\t\t\n\t\t\tstr += \"T\";\n\t\t\t\n\t\t\tif (h > 0)\n\t\t\t\tstr += h + \"H\";\n\t\t\t\n\t\t\tif (m > 0)\n\t\t\t\tstr += m + \"M\";\n\t\t\t\n\t\t\tif ((cs + s) > 0) {\n\t\t\t\tstr += s;\n\t\t\t\t\n\t\t\t\tif (cs > 0)\n\t\t\t\t\tstr += \".\" + cs;\n\t\t\t\t\n\t\t\t\tstr += \"S\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (str === \"\")\n\t\t\tstr = \"0S\";\n\t\t\n\t\tstr = \"P\" + str;\n\t\t\n\t\treturn str;\n\t};\n\n\tScormWrapper.prototype.convertDateToISO8601Timestamp = function(_value) {\n\t\tvar str;\n\t\t\n\t\tvar dtm = new Date(_value);\n\t\t\n\t\tvar y = dtm.getFullYear();\n\t\tvar mo = dtm.getMonth() + 1;\n\t\tvar d = dtm.getDate();\n\t\tvar h = dtm.getHours();\n\t\tvar m = dtm.getMinutes();\n\t\tvar s = dtm.getSeconds();\n\t\t\n\t\tmo = this.zeroPad(mo, 2);\n\t\td = this.zeroPad(d, 2);\n\t\th = this.zeroPad(h, 2);\n\t\tm = this.zeroPad(m, 2);\n\t\ts = this.zeroPad(s, 2);\n\t\t\n\t\tstr = y + \"-\" + mo + \"-\" + d + \"T\" + h + \":\" + m + \":\" + s;\n\t\t\n\t\treturn str;\n\t};\n\n\tScormWrapper.prototype.zeroPad = function(intNum, intNumDigits) {\n\t\tvar strTemp;\n\t\tvar intLen;\n\t\tvar i;\n\t\t\n\t\tstrTemp = new String(intNum);\n\t\tintLen = strTemp.length;\n\t\t\n\t\tif (intLen > intNumDigits) {\n\t\t\tstrTemp = strTemp.substr(0, intNumDigits);\n\t\t}\n\t\telse {\n\t\t\tfor (i = intLen; i < intNumDigits; i++)\n\t\t\t\tstrTemp = \"0\" + strTemp;\n\t\t}\n\t\t\n\t\treturn strTemp;\n\t};\n\n\tScormWrapper.prototype.trim = function(str) {\n\t\treturn str.replace(/^\\s*|\\s*$/g, \"\");\n\t};\n\n\tScormWrapper.prototype.isSCORM2004 = function() {\n\t\treturn this.scorm.version === \"2004\";\n\t};\n\n\tvar MatchingResponse = function(source, target){\n\t\tif (source.constructor == String){\n\t\t\tsource = ScormWrapper.getInstance().createResponseIdentifier(source, source);\n\t\t}\n\n\t\tif (target.constructor == String){\n\t\t\ttarget = ScormWrapper.getInstance().createResponseIdentifier(target, target);\n\t\t}\n\t\t\n\t\tthis.Source = source;\n\t\tthis.Target = target;\n\t};\n\n\tMatchingResponse.prototype.toString = function(){\n\t\treturn \"[Matching Response \" + this.Source + \", \" + this.Target + \"]\";\n\t};\n\n\tvar ResponseIdentifier = function(strShort, strLong) {\n\t\tthis.Short = new String(strShort);\n\t\tthis.Long = new String(strLong);\n\t};\n\n\tResponseIdentifier.prototype.toString = function() {\n\t\treturn \"[Response Identifier \" + this.Short + \", \" + this.Long + \"]\";\n\t};\n\n\treturn ScormWrapper;\n});\n\n","Logger = function() {\n\tthis.logArr = new Array();\n\tthis.registeredViews = new Array();\n};\n\n// static\nLogger.instance = null;\nLogger.LOG_TYPE_INFO = 0;\nLogger.LOG_TYPE_WARN = 1;\nLogger.LOG_TYPE_ERROR = 2;\nLogger.LOG_TYPE_DEBUG = 3;\n\nLogger.getInstance = function() {\n\tif (Logger.instance == null)\n\t\tLogger.instance = new Logger();\n\treturn Logger.instance;\n};\n\nLogger.prototype.getEntries = function() {\n\treturn this.logArr;\n};\n\nLogger.prototype.getLastEntry = function() {\n\treturn this.logArr[this.logArr.length - 1];\n};\n\nLogger.prototype.info = function(str) {\n\tthis.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_INFO};\n\tthis.updateViews();\n};\n\nLogger.prototype.warn = function(str) {\n\tthis.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_WARN};\n\tthis.updateViews();\n};\n\nLogger.prototype.error = function(str) {\n\tthis.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_ERROR};\n\tthis.updateViews();\n};\n\nLogger.prototype.debug = function(str) {\n\tthis.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_DEBUG};\n\tthis.updateViews();\n};\n\n//register a view\nLogger.prototype.registerView = function(_view) {\n\tthis.registeredViews[this.registeredViews.length] = _view;\n};\n\n//unregister a view\nLogger.prototype.unregisterView = function(_view) {\n\tfor (var i = 0; i < this.registeredViews.length; i++)\n\t\tif (this.registeredViews[i] == _view) {\n\t\t\tthis.registeredViews.splice(i, 1);\n\t\t\ti--;\n\t\t}\n};\n\n// update all views\nLogger.prototype.updateViews = function() {\n\tfor (var i = 0; i < this.registeredViews.length; i++) {\n\t\tif (this.registeredViews[i])\n\t\t\tthis.registeredViews[i].update(this);\n\t}\n};\ndefine(\"extensions/adapt-contrib-spoor/js/scorm/logger\", function(){});\n\n","define('extensions/adapt-contrib-spoor/js/scorm',[\n\t'./scorm/API',\n \t'./scorm/wrapper',\n\t'./scorm/logger',\n], function(API, wrapper, logger) {\n\n\t//Load and prepare SCORM API\n\n\treturn wrapper.getInstance();\n\n});\n","define('extensions/adapt-contrib-spoor/js/serializers/default',[\n    'coreJS/adapt'\n], function (Adapt) {\n\n    //Captures the completion status of the blocks\n    //Returns and parses a '1010101' style string\n\n    var serializer = {\n        serialize: function () {\n            return this.serializeSaveState('_isComplete');\n        },\n\n        serializeSaveState: function(attribute) {\n            if (Adapt.course.get('_latestTrackingId') === undefined) {\n                var message = \"This course is missing a latestTrackingID.\\n\\nPlease run the grunt process prior to deploying this module on LMS.\\n\\nScorm tracking will not work correctly until this is done.\";\n                console.error(message);\n            }\n\n            var excludeAssessments = Adapt.config.get('_spoor') && Adapt.config.get('_spoor')._tracking && Adapt.config.get('_spoor')._tracking._excludeAssessments;\n\n            // create the array to be serialised, pre-populated with dashes that represent unused tracking ids - because we'll never re-use a tracking id in the same course\n            var data = [];\n            var length = Adapt.course.get('_latestTrackingId') + 1;\n            for (var i = 0; i < length; i++) {\n                data[i] = \"-\";\n            }\n\n            // now go through all the blocks, replacing the appropriate dashes with 0 (incomplete) or 1 (completed) for each of the blocks\n            _.each(Adapt.blocks.models, function(model, index) {\n                var _trackingId = model.get('_trackingId'),\n                    isPartOfAssessment = model.getParent().get('_assessment'),\n                    state = model.get(attribute) ? 1: 0;\n\n                if(excludeAssessments && isPartOfAssessment) {\n                    state = 0;\n                }\n\n                if (_trackingId === undefined) {\n                    var message = \"Block '\" + model.get('_id') + \"' doesn't have a tracking ID assigned.\\n\\nPlease run the grunt process prior to deploying this module on LMS.\\n\\nScorm tracking will not work correctly until this is done.\";\n                    console.error(message);\n                } else {\n                    data[_trackingId] = state;\n                }\n            }, this);\n\n            return data.join(\"\");\n        },\n\n        deserialize: function (completion) {\n\n            _.each(this.deserializeSaveState(completion), function(state, blockTrackingId) {\n                if (state === 1) {\n                    this.markBlockAsComplete(Adapt.blocks.findWhere({_trackingId: blockTrackingId}));\n                }\n            }, this);\n\n        },    \n\n        deserializeSaveState: function (string) {\n            var completionArray = string.split(\"\");\n\n            for (var i = 0; i < completionArray.length; i++) {\n                if (completionArray[i] === \"-\") {\n                    completionArray[i] = -1;\n                } else {\n                    completionArray[i] = parseInt(completionArray[i], 10);\n                }\n            }\n\n            return completionArray;\n        },\n\n        markBlockAsComplete: function(block) {\n            if (!block || block.get('_isComplete')) {\n                return;\n            }\n        \n            block.getChildren().each(function(child) {\n                child.set('_isComplete', true);\n            }, this);\n        }\n\n    };\n\n    return serializer;\n});\n","//https://raw.githubusercontent.com/oliverfoster/SCORMSuspendDataSerializer 2015-06-27\n(function(_) {\n\n\tfunction toPrecision(number, precision) {\n\t\tif (precision === undefined) precision = 2\n\t\tvar multiplier = 1 * Math.pow(10, precision);\n\t\treturn Math.round(number * multiplier) / multiplier;\n\t}\n\n\tfunction BinaryToNumber(bin, length) {\n\t\treturn parseInt(bin.substr(0, length), 2);\n\t}\n\n\tfunction NumberToBinary(number, length) {\n\t\treturn Padding.fillLeft( number.toString(2), length );\n\t}\n\n\tvar Padding = {\n\t\taddLeft: function PaddingAddLeft(str, x , char) {\n\t\t\tchar = char || \"0\";\n\t\t\treturn (new Array( x + 1)).join(char) + str;\n\t\t},\n\t\taddRight: function PaddingAddRight(str, x, char) {\n\t\t\tchar = char || \"0\";\n\t\t\treturn  str + (new Array( x + 1)).join(char);\n\t\t},\n\t\tfillLeft: function PaddingFillLeft(str, x, char) {\n\t\t\tif (str.length < x) {\n\t        \tvar paddingLength = x - str.length;\n\t        \treturn Padding.addLeft(str, paddingLength, char)\n\t        }\n\t        return str;\n\t\t},\n\t\tfillRight: function PaddingFillLeft(str, x, char) {\n\t\t\tif (str.length < x) {\n\t        \tvar paddingLength = x - str.length;\n\t        \treturn Padding.addRight(str, paddingLength, char)\n\t        }\n\t        return str;\n\t\t},\n\t\tfillBlockLeft: function PaddingFillBlockRight(str, x, char) {\n\t\t\tif (str.length % x) {\n\t        \tvar paddingLength = x - (str.length % x);\n\t        \treturn Padding.addLeft(str, paddingLength, char)\n\t        }\n\t        return str;\n\t\t},\n\t\tfillBlockRight: function PaddingFillBlockRight(str, x, char) {\n\t\t\tif (str.length % x) {\n\t        \tvar paddingLength = x - (str.length % x);\n\t        \treturn Padding.addRight(str, paddingLength, char)\n\t        }\n\t        return str;\n\t\t}\n\t};\n\n\tfunction Base64() {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tvar firstArgumentType = typeof arguments[0];\n\t\t\tswitch (firstArgumentType) {\n\t\t\tcase \"number\":\n\t\t\t\treturn Base64._indexes[arguments[0]];\n\t\t\tcase \"string\":\n\t\t\t\treturn Base64._chars[arguments[0]];\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid arguments type\";\n\t\t\t}\n\t\tcase 2:\n\t\t\tvar char = arguments[0];\n\t\t\tvar index = arguments[1];\n\t\t\tBase64._chars[char] = index;\n\t\t\tBase64._indexes[index] = char;\n\t\t\treturn;\n\t\tdefault:\n\t\t\tthrow \"Invalid number of arguments\";\n\t\t}\n\t}\n\tBase64._chars = {};\n\tBase64._indexes = {};\n\t(function() {\n\t\tvar alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\t\tfor (var i = 0, l = alphabet.length; i<l; i++) {\n\t\t\tBase64(alphabet[i], i);\n\t\t}\n\t})();\n\n\n\tfunction DataType() {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tswitch (typeof  arguments[0]) {\n\t\t\tcase \"object\":\n\t\t\t\tvar item = arguments[0]\n\t\t\t\tif (DataType._types[item.type] === undefined) DataType._types[item.type] = [];\n\t\t\t\tDataType._types[item.type].push(item);\n\t\t\t\titem.index = DataType._indexes.length\n\t\t\t\tDataType._indexes.push(item);\n\t\t\t\tDataType[item.name] = item;\n\t\t\t\treturn;\n\t\t\tcase \"string\":\n\t\t\t\treturn DataType.getName(arguments[0]);\n\t\t\tcase \"number\":\n\t\t\t\treturn DataType.getIndex(arguments[0]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Argument type not allowed\";\n\t\t\t}\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\t\n\t}\n\tDataType.VARIABLELENGTHDESCRIPTORSIZE = 8;\n\tDataType._types = {};\n\tDataType._indexes = [];\n\tDataType.getName = function DataTypeGetName(name) {\n\t\tif (DataType[name])\n\t\t\treturn DataType[name];\n\t\tthrow \"Type name not found '\"+name+\"'\";\n\t};\n\tDataType.getIndex = function DataTypeGetIndex(index) {\n\t\tif (DataType._indexes[index])\n\t\t\treturn DataType._indexes[index];\n\t\tthrow \"Type index not found '\"+index+\"'\";\n\t};\n\tDataType.getTypes = function DataTypeGetTypes(type) {\n\t\tif (DataType._types[type])\n\t\t\treturn DataType._types[type];\n\t\tthrow \"Type not found '\"+type+\"'\";\n\t};\n\tDataType.checkBounds = function DataTypeCheckBounds(name, number) {\n\t\tvar typeDef = DataType(name);\n\t\tif (number > typeDef.max) throw name + \" value is larger than \"+typeDef.max;\n\t\tif (number < typeDef.min) throw name + \" value is smaller than \"+typeDef.min;\n\t};\n\tDataType.getNumberType = function DataTypeGetNumberType(number) {\n\t\tvar isDecimal = (number - Math.floor(number)) !== 0;\n\t\tvar numberDataTypes = DataType.getTypes(\"number\");\n\t\tfor (var t = 0, type; type = numberDataTypes[t++];) {\n\t\t\tif (number <= type.max && number >= type.min && (!isDecimal || isDecimal == type.decimal) ) {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\t};\n\tDataType.getVariableType = function DataTypeGetVariableType(variable) {\n\t\tvar variableNativeType = variable instanceof Array ? \"array\" : typeof variable;\n\t\tvar variableDataType;\n\n\t\tswitch(variableNativeType) {\n\t\tcase \"number\":\n\t\t\tvariableDataType = DataType.getNumberType(variable);\n\t\t\tbreak;\n\t\tcase \"string\":\n\t\t\tvariableDataType = DataType.getName(\"string\");\n\t\t\tbreak;\n\t\tdefault: \n\t\t\tvar supportedItemDataTypes = DataType.getTypes(variableNativeType);\n\t\t\tswitch (supportedItemDataTypes.length) {\n\t\t\tcase 1:\n\t\t\t\tvariableDataType = supportedItemDataTypes[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"Type not found '\"+variableNativeType+\"'\";\n\t\t\t}\n\t\t}\n\t\n\t\tif (!variableDataType) throw \"Cannot assess type '\"+variableNativeType+\"'\";\n\n\t\treturn variableDataType;\n\t};\n\tDataType.getArrayType = function getArrayType(arr) {\n\t\tvar foundItemTypes = [];\n\n\t\tfor (var i = 0, l = arr.length; i < l; i++) {\n\t\t\tvar item = arr[i];\n\t\t\tvar itemDataType = DataType.getVariableType(item);\n\n\t\t\tif (_.findWhere(foundItemTypes, { name: itemDataType.name })) continue;\n\t\n\t\t\tfoundItemTypes.push(itemDataType);\n\t\t}\n\n\t\tswitch (foundItemTypes.length) {\n\t\tcase 0:\n\t\t\tthrow \"Cannot determine array data types\";\n\t\tcase 1:\n\t\t\t//single value type\n\t\t \treturn foundItemTypes[0];\n\t\tdefault: \n\t\t\t//many value types\n\t\t\tvar nativeTypeNames = _.pluck(foundItemTypes, 'type');\n\t\t\tvar uniqueNativeTypeNames = _.uniq(nativeTypeNames);\n\t\t\tvar hasManyNativeTypes = (uniqueNativeTypeNames.length > 1);\n\n\t\t\tif (hasManyNativeTypes) return DataType(\"variable\"); //multiple types in array\n\n\t\t\t//single native type in array, multiple datatype lengths\n\t\t\tswitch (uniqueNativeTypeNames[0]) {\n\t\t\tcase \"number\":\n\t\t\t\tvar foundDecimal = _.findWhere(foundItemTypes, { decimal: true});\n\t\t\t\tif (foundDecimal) return foundDecimal;\n\t\t\t\treturn _.max(foundItemTypes, function(type) {\n\t\t\t\t\treturn type.max;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow \"Unsupported data types\";\n\t\t}\n\t\t\n\t};\n\t(function() {\n\t\tvar types = [\n\t\t\t{\n\t\t\t\t\"size\": \"fixed\",\n\t\t\t\t\"length\": 1,\n\t\t\t\t\"name\": \"boolean\",\n\t\t\t\t\"type\": \"boolean\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"max\": 15,\n\t\t\t\t\"min\": 0,\n\t\t\t\t\"decimal\": false,\n\t\t\t\t\"size\": \"fixed\",\n\t\t\t\t\"length\": 4,\n\t\t\t\t\"name\": \"half\",\n\t\t\t\t\"type\": \"number\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"max\": 255,\n\t\t\t\t\"min\": 0,\n\t\t\t\t\"decimal\": false,\n\t\t\t\t\"size\": \"fixed\",\n\t\t\t\t\"length\": 8,\n\t\t\t\t\"name\": \"byte\",\n\t\t\t\t\"type\": \"number\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"max\": 65535,\n\t\t\t\t\"min\": 0,\n\t\t\t\t\"decimal\": false,\n\t\t\t\t\"size\": \"fixed\",\n\t\t\t\t\"length\": 16,\n\t\t\t\t\"name\": \"short\",\n\t\t\t\t\"type\": \"number\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"max\": 4294967295,\n\t\t\t\t\"min\": 0,\n\t\t\t\t\"decimal\": false,\n\t\t\t\t\"size\": \"fixed\",\n\t\t\t\t\"length\": 32,\n\t\t\t\t\"name\": \"long\",\n\t\t\t\t\"type\": \"number\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"max\": 4294967295,\n\t\t\t\t\"min\": -4294967295,\n\t\t\t\t\"decimal\": true,\n\t\t\t\t\"precision\": 2,\n\t\t\t\t\"size\": \"variable\",\n\t\t\t\t\"name\": \"double\",\n\t\t\t\t\"type\": \"number\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"base16\",\n\t\t\t\t\"size\": \"variable\",\n\t\t\t\t\"type\": \"string\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"base64\",\n\t\t\t\t\"size\": \"variable\",\n\t\t\t\t\"type\": \"string\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"array\",\n\t\t\t\t\"size\": \"variable\",\n\t\t\t\t\"type\": \"array\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"variable\",\n\t\t\t\t\"size\": \"variable\",\n\t\t\t\t\"type\": \"variable\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"string\",\n\t\t\t\t\"size\": \"variable\",\n\t\t\t\t\"type\": \"string\"\n\t\t\t}\n\t\t];\n\t\tfor (var i = 0, type; type = types[i++];) {\n\t\t\tDataType(type);\n\t\t}\n\t})();\n\n\t\n\n\tfunction Converter(fromType, toType) {\n\t\tfromType = Converter.translateTypeAlias(fromType);\n\t\ttoType = Converter.translateTypeAlias(toType);\n\n\t\tvar args = [].slice.call(arguments, 2);\n\n\t\tif (fromType != \"binary\" && toType != \"binary\") {\n\t\t\tif (!Converter._converters[fromType]) throw \"Type not found '\" + fromType + \"'\";\n\t\t\tif (!Converter._converters[fromType]['binary']) throw \"Type not found 'binary'\";\n\t\t\t\n\t\t\tvar bin = Converter._converters[fromType]['binary'].call(this, args[0], Converter.WRAPOUTPUT);\n\n\t\t\tif (!Converter._converters['binary'][toType]) throw \"Type not found '\"+toType+\"'\";\n\n\t\t\treturn Converter._converters['binary'][toType].call(this, bin, Converter.WRAPOUTPUT);\n\t\t}\n\n\t\tif (!Converter._converters[fromType]) throw \"Type not found '\" + fromType + \"'\";\n\t\tif (!Converter._converters[fromType][toType]) throw \"Type not found '\" + toType + \"'\";\n\n\t\treturn Converter._converters[fromType][toType].call(this, args[0], Converter.WRAPOUTPUT);\n\t}\n\tConverter.WRAPOUTPUT = false;\n\tConverter.translateTypeAlias = function ConverterTranslateTypeAlias(type) {\n\t\ttype = type.toLowerCase();\n\t\tfor (var Type in Converter._typeAliases) {\n\t\t\tif (Type == type || (\" \"+Converter._typeAliases[Type].join(\" \")+\" \").indexOf(\" \"+type+\" \") >= 0 ) return Type;\n\t\t}\n\t\tthrow \"Type not found '\" + type + \"'\";\n\t};\n\tConverter._typeAliases = {\n\t\t\"base64\": [ \"b64\" ],\n\t\t\"base16\" : [ \"hex\", \"b16\" ],\n\t\t\"double\": [ \"dbl\", \"decimal\", \"d\" ],\n\t\t\"long\": [ \"lng\", \"l\" ],\n\t\t\"short\": [ \"s\" ],\n\t\t\"byte\" : [ \"b\" ],\n\t\t\"half\": [ \"h\" ],\n\t\t\"number\": [ \"num\", \"n\" ],\n\t\t\"binary\": [ \"bin\" ],\n\t\t\"boolean\": [ \"bool\" ],\n\t\t\"array\": [ \"arr\" ]\n\t};\n\tConverter._variableWrapLength = function ConverterVariableWrapLength(bin) {\n\t\tvar variableLength = bin.length;\n\t\tvar binLength = NumberToBinary(variableLength, DataType.VARIABLELENGTHDESCRIPTORSIZE)\n\n\t\treturn binLength + bin;\n\t};\n\tConverter._variableLength = function ConverterVariableLength(bin) {\n\t\tvar VLDS =  DataType.VARIABLELENGTHDESCRIPTORSIZE;\n\t\tvar variableLength = BinaryToNumber(bin, VLDS );\n\t\treturn variableLength;\n\t};\n\tConverter._variableUnwrapLength = function ConverterVariableUnwrapLength(bin) {\n\t\tvar VLDS =  DataType.VARIABLELENGTHDESCRIPTORSIZE;\n\t\tvar variableLength = BinaryToNumber(bin, VLDS );\n\n\t\treturn bin.substr( VLDS, variableLength);\n\t};\n\tConverter._converters = {\n\t\t\"base64\": {\n\t\t\t\"binary\": function ConverterBase64ToBinary(base64) { //TODO PADDING... ?\n\t\t\t\tvar firstByte = Base64(base64.substr(0,1));\n\t\t\t\tvar binFirstByte = NumberToBinary(firstByte, 6);\n\t\t\t\tvar paddingLength = BinaryToNumber(binFirstByte, 6);\n\n\t\t\t    var bin = \"\";\n\t\t\t    for (var i = 0, ch; ch = base64[i++];) {\n\t\t\t        var block = Base64(ch).toString(2);\n\t\t\t        block = Padding.fillLeft(block, 6);\n\t\t\t        bin += block;\n\t\t\t    }\n\t\t\t    bin =  bin.substr(6+paddingLength);\n\t\t\t    return bin;\n\t\t\t}\n\t\t},\n\t\t\"base16\": {\n\t\t\t\"binary\": function ConverterBase16ToBinary(hex) {\n\t\t\t\tvar firstByte = Base64(base64.substr(0,1));\n\t\t\t\tvar binFirstByte = NumberToBinary(firstByte, 4);\n\t\t\t\tvar paddingLength = BinaryToNumber(binFirstByte, 4);\n\n\t\t\t    var bin = \"\";\n\t\t\t    for (var i = 0, ch; ch = hex[i++];) {\n\t\t\t        var block = parseInt(ch, 16).toString(2);\n\t\t\t        block = Padding.fillLeft(block, 4);\n\t\t\t        bin += block;\n\t\t\t    }\n\n\t\t\t     bin =  bin.substr(6+paddingLength);\n\t\t\t    return bin;\n\t\t\t}\n\t\t},\n\t\t\"double\": {\n\t\t\t\"binary\": function ConverterDoubleToBinary(dbl, wrap) {\n\t\t\t\tvar typeDef = DataType(\"double\");\n\t\t\t\tDataType.checkBounds(\"double\", dbl);\n\n\t\t\t\tdbl = toPrecision(dbl, typeDef.precision);\n\n\t\t\t\tvar dblStr = dbl.toString(10);\n\n\t\t\t\tvar isMinus = dbl < 0;\n\t\t\t\n\t\t\t\tvar baseStr, exponentStr, highStr, lowStr, decimalPosition, hasDecimal;\n\n\t\t\t\t\n\t\t\t\tvar exponentPos = dblStr.indexOf(\"e\");\n\t\t\t\tif (exponentPos > -1) {\n\t\t\t\t\t//exponential float representation \"nE-x\"\n\t\t\t\t\tbaseStr = dblStr.substr(0, exponentPos);\n\t\t\t\t\texponentStr = Math.abs(dblStr.substr(exponentPos+1));\n\n\t\t\t\t\tif (isMinus) baseStr = baseStr.substr(1);\n\n\t\t\t\t\tdecimalPosition = baseStr.indexOf(\".\");\n\t\t\t\t\thasDecimal = (decimalPosition > -1);\n\n\t\t\t\t\tif (hasDecimal) {\n\t\t\t\t\t\thighStr = baseStr.substr(0, decimalPosition);\n\t\t\t\t\t\tlowStr = baseStr.substr(decimalPosition+1);\n\n\t\t\t\t\t\texponentStr = (Math.abs(exponentStr) + lowStr.length);\n\n\t\t\t\t\t\tbaseStr = highStr + lowStr;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t//normal long float representation \"0.00000000\"\n\t\t\t\t\tbaseStr = dblStr;\n\t\t\t\t\texponentStr = \"0\";\n\n\t\t\t\t\tif (isMinus) dblStr = dblStr.substr(1);\n\n\t\t\t\t\tdecimalPosition = dblStr.indexOf(\".\");\n\t\t\t\t\thasDecimal = (decimalPosition > -1);\n\t\t\t\t\tif (hasDecimal) {\n\t\t\t\t\t\thighStr = dblStr.substr(0, decimalPosition);\n\t\t\t\t\t\tlowStr = dblStr.substr(decimalPosition+1);\n\n\t\t\t\t\t\texponentStr = (lowStr.length);\n\t\t\t\t\t\tif (highStr == \"0\") {\n\t\t\t\t\t\t\tbaseStr = parseInt(lowStr, 10).toString(10);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbaseStr = highStr + lowStr;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbaseStr = dblStr;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar bin = [];\n\n\t\t\t\tvar binLong = Padding.fillBlockLeft (parseInt(baseStr, 10).toString(2), 4);\n\t\t\t\tvar binMinus = isMinus ? \"1\" : \"0\";\n\t\t\t\tvar binExponent = Padding.fillLeft( parseInt(exponentStr, 10).toString(2), 7);\n\t\t\t\t\n\t\t\t\tbin.push( binMinus );\n\t\t\t\tbin.push( binExponent );\n\t\t\t\tbin.push( binLong );\n\n\t\t\t\tif (wrap === false) {\n\t\t\t\t\treturn bin.join(\"\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Converter._variableWrapLength(bin.join(\"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"long\": {\n\t\t\t\"binary\": function ConverterLongToBinary(value) {\n\t\t\t\tvar typeDef = DataType(\"long\");\n\t\t\t\tDataType.checkBounds(\"long\", value);\n\t\t\t\tvalue = toPrecision(value, 0);\n\t\t\t\treturn Padding.fillLeft(value.toString(2), typeDef.length);\n\t\t\t}\n\t\t},\n\t\t\"short\": {\n\t\t\t\"binary\": function ConverterShortToBinary(value) {\n\t\t\t\tvar typeDef = DataType(\"short\");\n\t\t\t\tDataType.checkBounds(\"short\", value);\n\t\t\t\tvalue = toPrecision(value, 0);\n\t\t\t\treturn Padding.fillLeft(value.toString(2), typeDef.length);\n\t\t\t}\n\t\t},\n\t\t\"byte\": {\n\t\t\t\"binary\": function ConverterByteToBinary(value) {\n\t\t\t\tvar typeDef = DataType(\"byte\");\n\t\t\t\tDataType.checkBounds(\"byte\", value);\n\t\t\t\tvalue = toPrecision(value, 0);\n\t\t\t\treturn Padding.fillLeft(value.toString(2), typeDef.length);\n\t\t\t}\n\t\t},\n\t\t\"half\": {\n\t\t\t\"binary\": function ConverterHalfToBinary(value) {\n\t\t\t\tvar typeDef = DataType(\"half\");\n\t\t\t\tDataType.checkBounds(\"half\", value);\n\t\t\t\tvalue = toPrecision(value, 0);\n\t\t\t\treturn Padding.fillLeft(value.toString(2), typeDef.length);\n\t\t\t}\n\t\t},\n\t\t\"boolean\": {\n\t\t\t\"binary\": function ConverterBooleanToBinary(bool) {\n\t\t\t\treturn bool ? \"1\" : \"0\";\n\t\t\t},\n\t\t},\n\t\t\"array\": {\n\t\t\t\"binary\": function ConverterArrayToBinary(arr, wrap) { //TODO PADDING NOT GOOD\n\t\t\t\tvar typeDef = DataType(\"array\");\n\t\t\t\tvar arrayItemType = DataType.getArrayType(arr);\n\t\t\t\tvar isVariableArray = arrayItemType.name == \"vairable\";\n\n\t\t\t\tif (isVariableArray) {\n\t\t\t\t\tvar bin = half2bin(15);\n\t\t\t\t\t//variable array\n\t\t\t\t\treturn bin;\n\t\t\t\t} else {\n\t\t\t\t\tvar binArrayIdentifier = Converter._converters['half']['binary'](arrayItemType.index);\n\n\t\t\t\t\tvar binItemsArray = [];\n\t\t\t\t\tfor (var i = 0, l = arr.length; i < l; i++) {\n\t\t\t\t\t\tvar item = arr[i];\n\t\t\t\t\t\tvar binItem = Converter._converters[arrayItemType.name]['binary'](item);\n\t\t\t\t\t\t//console.log(\"binItem\", binItem);\n\t\t\t\t\t\tbinItemsArray.push( binItem );\n\t\t\t\t\t}\n\n\t\t\t\t\tvar binItems = binItemsArray.join(\"\");\n\n\t\t\t\t\tvar paddingLength = 0;\n\t\t\t\t\tif (binItems.length % 4) paddingLength = 4 - (binItems.length % 4);\n\t\t\t\t\tvar binPaddingLen = NumberToBinary(paddingLength, 2);\n\n\t\t\t\t\tvar binPadding = (new Array(paddingLength+1)).join(\"0\");\n\n\t\t\t\t\tvar bin = [];\n\t\t\t\t\tbin.push(binArrayIdentifier);\n\t\t\t\t\tbin.push(binPaddingLen);\n\t\t\t\t\tbin.push(binPadding);\n\t\t\t\t\tbin.push(binItems);\n\n\t\t\t\t\tvar finished = bin.join(\"\");\n\t\t\t\t\t//console.log(\"unwrapped\", finished);\n\n\t\t\t\t\tif (wrap === false) return finished;\n\n\t\t\t\t\tvar wrapped = Converter._variableWrapLength( finished);\n\t\t\t\t\t//console.log(\"wrapped\", wrapped);\n\n\t\t\t\t\treturn wrapped;\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\t\t\"binary\": {\n\t\t\t\"array\": function ConverterBinaryToArray(bin, wrap) { //TODO PADDING NOT GOOD\n\t\t\t\tvar typeDef = DataType(\"array\");\n\n\t\t\t\t//console.log(\"wrapped\", bin);\n\t\t\t\tif (wrap !== false)\n\t\t\t\t\tbin = Converter._variableUnwrapLength( bin);\n\t\t\t\t//console.log(\"unwrapped\", bin);\n\n\t\t\t\tvar binArrayIdentifier = bin.substr(0, 4);\n\t\t\t\tvar binPaddingLen = bin.substr(4 , 2);\n\n\t\t\t\tvar arrayIdentifier = Converter._converters['binary'][ 'half' ]( binArrayIdentifier );\n\t\t\t\tvar paddingLength = BinaryToNumber( binPaddingLen, 2 );\n\n\t\t\t\tvar dataStart = 4 + 2 + paddingLength;\n\t\t\t\tvar dataLength = bin.length - dataStart;\n\n\t\t\t\tvar binItems = bin.substr(dataStart, dataLength );\n\n\t\t\t\tvar arrayItemType = DataType(arrayIdentifier);\n\t\t\t\tvar isVariableArray = arrayItemType.name == \"variable\";\n\n\t\t\t\tvar rtn = [];\n\t\t\t\tif (isVariableArray) {\n\n\t\t\t\t} else {\n\t\t\t\t\tvar hasVariableLengthChildren = arrayItemType.size == \"variable\";\n\t\t\t\t\tif (hasVariableLengthChildren) {\n\t\t\t\t\t\tvar VLDS = DataType.VARIABLELENGTHDESCRIPTORSIZE;\n\t\t\t\t\t\twhile ( binItems != \"\" ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar variableLength = Converter._variableLength( binItems );\n\t\t\t\t\t\t\tvar binItem = binItems.substr(0, VLDS + variableLength);\n\t\t\t\t\t\t\tbinItems = binItems.substr(VLDS+variableLength);\n\t\t\t\t\t\t\t//console.log(\"binItem\", binItem, BinaryToNumber(binItem, 16));\n\n\t\t\t\t\t\t\trtn.push( Converter._converters['binary'][ arrayItemType.name ]( binItem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile ( binItems != \"\" ) {\n\t\t\t\t\t\t\tvar binItem = binItems.substr(0, arrayItemType.length);\n\t\t\t\t\t\t\tbinItems = binItems.substr(arrayItemType.length);\n\n\t\t\t\t\t\t\trtn.push( Converter._converters['binary'][ arrayItemType.name ](binItem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\treturn rtn;\n\n\t\t\t},\n\t\t\t\"base64\": function ConverterBinaryToBase64(bin) { //TODO PADDING NOT GOOD\n\t\t\t\tvar paddingLength = 0;\n\t\t\t\tif (bin.length % 6) paddingLength = 6 - (bin.length % 6);\n\t\t\t\tbinPaddingLen = NumberToBinary(paddingLength, 6);\n\t\t\t\tbinPadding = Padding.addLeft(\"\", paddingLength);\n\t\t\t\tbin = binPaddingLen + binPadding + bin;\n\n\t\t\t\tvar binLength = bin.length;\n\t\t\t    var base64 = \"\";\n\t\t\t    for (var b = 0; b < 10000; b++) {\n\t\t\t        if (b*6 >= binLength) break;\n\t\t\t     \n\t\t\t        var block = bin.substr(b*6,6);\n\t\t\t        base64 += Base64(parseInt(block, 2));\n\t\t\t    }\n\n\t\t\t    return base64;\n\t\t\t},\n\t\t\t\"base16\": function ConverterBinaryToBase16(bin) {\n\t\t\t\tvar paddingLength = 0;\n\t\t\t\tif (bin.length % 4) paddingLength = 4 - (bin.length % 4);\n\t\t\t\tbinPaddingLen = NumberToBinary(paddingLength, 4);\n\t\t\t\tbinPadding = Padding.addLeft(\"\", paddingLength);\n\t\t\t\tbin = binPaddingLen + binPadding + bin;\n\n\t\t\t    var binLength = bin.length;\n\t\t\t    var hex = \"\";\n\t\t\t    for (var b = 0; b < 10000; b++) {\n\t\t\t        if (b*4 >= binLength) break;\n\t\t\t     \n\t\t\t        var block = bin.substr(b*4,4);\n\t\t\t        hex += parseInt(block, 2).toString(16);\n\t\t\t    }\n\t\t\t    return hex;\n\t\t\t},\n\t\t\t\"double\": function ConverterBinaryToDouble(bin, wrap) {\n\t\t\t\tvar typeDef = DataType(\"double\");\n\t\t\t\t\n\t\t\t\tif (wrap !== false)\n\t\t\t\t\tbin = Converter._variableUnwrapLength(bin);\n\n\t\t\t\tvar isMinus = bin.substr(0 ,1) == 1;\n\n\t\t\t\tvar exponentByte = parseInt(\"0\" + bin.substr(1, 7), 2);\n\t\t\t\tvar baseLong = parseInt( bin.substr(8, bin.length), 2);\n\n\t\t\t\tvar dbl = parseFloat(baseLong+\"E-\"+exponentByte, 10);\n\t\t\t\tif (isMinus) dbl = dbl * -1;\n\n\t\t\t\treturn dbl;\n\t\t\t},\n\t\t\t\"long\": function ConverterBinaryToLong(bin) {\n\t\t\t\treturn parseInt(bin.substr(0, 32), 2);\n\t\t\t},\n\t\t\t\"short\": function ConverterBinaryToShort(bin) {\n\t\t\t\treturn parseInt(bin.substr(0, 16), 2);\n\t\t\t},\n\t\t\t\"byte\": function ConverterBinaryToByte(bin) {\n\t\t\t\treturn parseInt(bin.substr(0, 8), 2);\n\t\t\t},\n\t\t\t\"half\": function ConverterBinaryToHalf(bin) {\n\t\t\t\treturn parseInt(bin.substr(0, 4), 2);\n\t\t\t},\n\t\t\t\"boolean\": function ConverterBinaryToBoolean(bin) {\n\t\t\t\treturn bin.substr(0,1) == \"1\" ? true: false;\n\t\t\t},\n\t\t\t\"number\": function ConverterBinaryToNumber(bin) {\n\t\t\t\treturn parseInt(bin, 2);\n\t\t\t}\n\t\t}\n\t};\n\t\n\twindow.SCORMSuspendData = {\n\t\tserialize: function SCORMSuspendDataSerialize(arr) {\n\t\t\treturn Converter (\"array\", \"base64\", arr);\n\t\t},\n\t\tdeserialize: function SCORMSuspendDataDeserialize(base64) {\n\t\t\treturn Converter(\"base64\", \"array\", base64);\n\t\t},\n\t\tBase64: Base64,\n\t\tConverter: Converter,\n\t\tDataType: DataType\n\t};\n\n\n})(_);\n\ndefine(\"extensions/adapt-contrib-spoor/js/serializers/scormSuspendDataSerializer\", function(){});\n\n","define('extensions/adapt-contrib-spoor/js/serializers/questions',[\n    'coreJS/adapt',\n    './scormSuspendDataSerializer'\n], function (Adapt) {\n\n    //Captures the completion status and user selections of the question components\n    //Returns and parses a base64 style string\n    var includes = {\n        \"_isQuestionType\": true,\n        \"_isResetOnRevisit\": false\n    };\n\n    var serializer = {\n        serialize: function () {\n            return this.serializeSaveState();\n        },\n\n        serializeSaveState: function() {\n            if (Adapt.course.get('_latestTrackingId') === undefined) {\n                var message = \"This course is missing a latestTrackingID.\\n\\nPlease run the grunt process prior to deploying this module on LMS.\\n\\nScorm tracking will not work correctly until this is done.\";\n                console.error(message);\n                return \"\";\n            }\n\n            var rtn = \"\";\n            try {\n                var data = this.captureData();\n                if (data.length === 0) return \"\";\n                rtn = SCORMSuspendData.serialize(data);\n            } catch(e) {\n                console.error(e);\n            }\n\n            return rtn;\n        },\n\n        captureData: function() {\n            var data = [];\n            \n            var trackingIds = Adapt.blocks.pluck(\"_trackingId\");\n            var blocks = {};\n            var countInBlock = {};\n\n            for (var i = 0, l = trackingIds.length; i < l; i++) {\n\n                var trackingId = trackingIds[i];\n                var blockModel = Adapt.blocks.findWhere({_trackingId: trackingId });\n                var componentModels = blockModel.getChildren().where(includes);\n\n                for (var c = 0, cl = componentModels.length; c < cl; c++) {\n\n                    var component = componentModels[c].toJSON();\n                    var blockId = component._parentId;\n\n                    if (!blocks[blockId]) {\n                        blocks[blockId] = blockModel.toJSON();\n                    }\n\n                    var block = blocks[blockId];\n                    if (countInBlock[blockId] === undefined) countInBlock[blockId] = -1;\n                    countInBlock[blockId]++;\n\n                    var blockLocation = countInBlock[blockId];\n\n                    if (component['_isInteractionComplete'] === false || component['_isComplete'] === false) {\n                        //if component is not currently complete skip it\n                        continue;\n                    }\n\n                    var hasUserAnswer = (component['_userAnswer'] !== undefined);\n                    var isUserAnswerArray = (component['_userAnswer'] instanceof Array);\n\n\n                    var numericParameters = [\n                            blockLocation,\n                            block['_trackingId'],\n                            component['_score'] || 0,\n                            component['_attemptsLeft'] || 0\n                        ];\n\n                    var booleanParameters = [\n                            hasUserAnswer,\n                            isUserAnswerArray,\n                            component['_isInteractionComplete'],\n                            component['_isSubmitted'],\n                            component['_isCorrect'] || false\n                        ];\n\n                    var dataItem = [\n                        numericParameters,\n                        booleanParameters\n                    ];\n\n\n                    if (hasUserAnswer) {\n                        var userAnswer = isUserAnswerArray ? component['_userAnswer'] : [component['_userAnswer']];\n\n                        var arrayType = SCORMSuspendData.DataType.getArrayType(userAnswer);\n\n                        switch(arrayType.name) {\n                        case \"string\": case \"variable\":\n                            console.log(\"Cannot store _userAnswers from component \" + component._id + \" as array is of variable or string type.\");\n                            continue;\n                        }\n\n                        dataItem.push(userAnswer);\n                    }\n\n                    data.push(dataItem);\n\n                }\n\n            }\n\n            return data;\n\n        },\n\n        deserialize: function (str) {\n\n            try {\n                var data = SCORMSuspendData.deserialize(str);\n                this.releaseData( data );\n            } catch(e) {\n                console.error(e);\n            }\n            \n        },    \n\n        releaseData: function (arr) {\n            \n            for (var i = 0, l = arr.length; i < l; i++) {\n                var dataItem = arr[i];\n\n                var numericParameters = dataItem[0];\n                var booleanParameters = dataItem[1];\n\n                var blockLocation = numericParameters[0];\n                var trackingId = numericParameters[1];\n                var score = numericParameters[2];\n                var attemptsLeft = numericParameters[3] || 0;\n\n                var hasUserAnswer = booleanParameters[0];\n                var isUserAnswerArray = booleanParameters[1];\n                var isInteractionComplete = booleanParameters[2];\n                var isSubmitted = booleanParameters[3];\n                var isCorrect = booleanParameters[4];\n\n                var block = Adapt.blocks.findWhere({_trackingId: trackingId});\n                var components = block.getChildren();\n                components = components.where(includes);\n                var component = components[blockLocation];\n\n                component.set(\"_isComplete\", true);\n                component.set(\"_isInteractionComplete\", isInteractionComplete);\n                component.set(\"_isSubmitted\", isSubmitted);\n                component.set(\"_score\", score);\n                component.set(\"_isCorrect\", isCorrect);\n                component.set(\"_attemptsLeft\", attemptsLeft);\n\n                if (hasUserAnswer) {\n                    var userAnswer = dataItem[2];\n                    if (!isUserAnswerArray) userAnswer = userAnswer[0];\n\n                    component.set(\"_userAnswer\", userAnswer);\n                }\n\n\n            }\n        }\n    };\n\n    return serializer;\n});\n\n","define('extensions/adapt-contrib-spoor/js/adapt-stateful-session',[\n\t'coreJS/adapt',\n\t'./serializers/default',\n\t'./serializers/questions'\n], function(Adapt, serializer, questions) {\n\n\t//Implements Adapt session statefulness\n\t\n\tvar AdaptStatefulSession = _.extend({\n\n\t\t_sessionID: null,\n\t\t_config: null,\n\t\t_shouldStoreResponses: false,\n\t\t_shouldRecordInteractions: true,\n\n\t//Session Begin\n\t\tinitialize: function() {\n\t\t\tthis.getConfig();\n\t\t\tthis.restoreSessionState();\n\t\t\tthis.assignSessionId();\n\t\t\tthis.setupEventListeners();\n\t\t},\n\n\t\tgetConfig: function() {\n\t\t\tthis._config = Adapt.config.has('_spoor')\n\t\t\t\t? Adapt.config.get('_spoor')\n\t\t\t\t: false;\n\t\t\t\n\t\t\tthis._shouldStoreResponses = (this._config && this._config._tracking && this._config._tracking._shouldStoreResponses);\n\t\t\t\n\t\t\t// default should be to record interactions, so only avoid doing that if _shouldRecordInteractions is set to false\n\t\t\tif (this._config && this._config._tracking && this._config._tracking._shouldRecordInteractions === false) {\n\t\t\t\tthis._shouldRecordInteractions = false;\n\t\t\t}\n\t\t},\n\n\t\tsaveSessionState: function() {\n\t\t\tvar sessionPairs = this.getSessionState();\n\t\t\tAdapt.offlineStorage.set(sessionPairs);\n\t\t},\n\n\t\trestoreSessionState: function() {\n\t\t\tvar sessionPairs = Adapt.offlineStorage.get();\n\t\t\tvar hasNoPairs = _.keys(sessionPairs).length === 0;\n\n\t\t\tif (hasNoPairs) return;\n\n\t\t\tif (sessionPairs.completion) serializer.deserialize(sessionPairs.completion);\n\t\t\tif (sessionPairs.questions && this._shouldStoreResponses) questions.deserialize(sessionPairs.questions);\n\t\t\tif (sessionPairs._isCourseComplete) Adapt.course.set('_isComplete', sessionPairs._isCourseComplete);\t\t\t\n\t\t\tif (sessionPairs._isAssessmentPassed) Adapt.course.set('_isAssessmentPassed', sessionPairs._isAssessmentPassed);\n\t\t},\n\n\t\tgetSessionState: function() {\n\t\t\tvar sessionPairs = {\n\t\t\t\t\"completion\": serializer.serialize(),\n\t\t\t\t\"questions\": (this._shouldStoreResponses == true ? questions.serialize() : \"\"),\n\t\t\t\t\"_isCourseComplete\": Adapt.course.get(\"_isComplete\") || false,\n\t\t\t\t\"_isAssessmentPassed\": Adapt.course.get('_isAssessmentPassed') || false\n\t\t\t};\n\t\t\treturn sessionPairs;\n\t\t},\n\n\t\tassignSessionId: function () {\n\t\t\tthis._sessionID = Math.random().toString(36).slice(-8);\n\t\t},\n\n\t//Session In Progress\n\t\tsetupEventListeners: function() {\n\t\t\tthis._onWindowUnload = _.bind(this.onWindowUnload, this);\n\t\t\t$(window).on('unload', this._onWindowUnload);\n\n\t\t\tif (this._shouldStoreResponses) {\n\t\t\t\tthis.listenTo(Adapt.components, 'change:_isInteractionComplete', this.onQuestionComponentComplete);\n\t\t\t}\n\n\t\t\tif(this._shouldRecordInteractions) {\n\t\t\t\tthis.listenTo(Adapt, 'questionView:recordInteraction', this.onQuestionRecordInteraction);\n\t\t\t}\n\n\t\t\tthis.listenTo(Adapt.blocks, 'change:_isComplete', this.onBlockComplete);\n\t\t\tthis.listenTo(Adapt.course, 'change:_isComplete', this.onCompletion);\n\t\t\tthis.listenTo(Adapt, 'assessment:complete', this.onAssessmentComplete);\n\t\t\tthis.listenTo(Adapt, 'questionView:complete', this.onQuestionComplete);\n\t\t\tthis.listenTo(Adapt, 'questionView:reset', this.onQuestionReset);\n\t\t},\n\n\t\tonBlockComplete: function(block) {\n\t\t\tthis.saveSessionState();\n\t\t},\n\n\t\tonQuestionComponentComplete: function(component) {\n\t\t\tif (!component.get(\"_isQuestionType\")) return;\n\n\t\t\tthis.saveSessionState();\n\t\t},\n\n\t\tonCompletion: function() {\n\t\t\tif (!this.checkTrackingCriteriaMet()) return;\n\n\t\t\tthis.saveSessionState();\n\t\t\t\n\t\t\tAdapt.offlineStorage.set(\"status\", this._config._reporting._onTrackingCriteriaMet);\n\t\t},\n\n\t\tonAssessmentComplete: function(stateModel) {\n\t\t\tAdapt.course.set('_isAssessmentPassed', stateModel.isPass)\n\t\t\t\n\t\t\tthis.saveSessionState();\n\n\t\t\tthis.submitScore(stateModel.scoreAsPercent);\n\n\t\t\tif (stateModel.isPass) {\n\t\t\t\tthis.onCompletion();\n\t\t\t} else if (this._config && this._config._tracking._requireAssessmentPassed) {\n\t\t\t\tthis.submitAssessmentFailed();\n\t\t\t}\n\t\t},\n\n\t\tonQuestionRecordInteraction:function(questionView) {\n\t\t\tvar id = questionView.model.get('_id');\n\t\t\tvar latency = questionView.getLatency();\n\t\t\tvar response = questionView.getResponse();\n\t\t\tvar responseType = questionView.getResponseType();\n\t\t\tvar result = questionView.isCorrect();\n\t\t\t\n\t\t\tAdapt.offlineStorage.set(\"interaction\", id, response, result, latency, responseType);\n\t\t},\n\n\t\tsubmitScore: function(score) {\n\t\t\tif (this._config && !this._config._tracking._shouldSubmitScore) return;\n\t\t\t\n\t\t\tAdapt.offlineStorage.set(\"score\", score, 0, 100);\n\t\t},\n\n\t\tsubmitAssessmentFailed: function() {\n\t\t\tif (this._config && this._config._reporting.hasOwnProperty(\"_onAssessmentFailure\")) {\n\t\t\t\tvar onAssessmentFailure = this._config._reporting._onAssessmentFailure;\n\t\t\t\tif (onAssessmentFailure === \"\") return;\n\t\t\t\t\t\n\t\t\t\tAdapt.offlineStorage.set(\"status\", onAssessmentFailure);\n\t\t\t}\n\t\t},\n\n\t\tonQuestionComplete: function(questionView) {\n\t\t\tquestionView.model.set('_sessionID', this._sessionID);\n\t\t},\n\n\t\tonQuestionReset: function(questionView) {\n\t\t\tif (this._sessionID !== questionView.model.get('_sessionID')) {\n\t\t\t\tquestionView.model.set('_isEnabledOnRevisit', true);\n\t\t\t}\n\t\t},\n\t\t\n\t\tcheckTrackingCriteriaMet: function() {\n\t\t\tvar criteriaMet = false;\n\n\t\t\tif (!this._config) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this._config._tracking._requireCourseCompleted && this._config._tracking._requireAssessmentPassed) { // user must complete all blocks AND pass the assessment\n\t\t\t\tcriteriaMet = (Adapt.course.get('_isComplete') && Adapt.course.get('_isAssessmentPassed'));\n\t\t\t} else if (this._config._tracking._requireCourseCompleted) { //user only needs to complete all blocks\n\t\t\t\tcriteriaMet = Adapt.course.get('_isComplete');\n\t\t\t} else if (this._config._tracking._requireAssessmentPassed) { // user only needs to pass the assessment\n\t\t\t\tcriteriaMet = Adapt.course.get('_isAssessmentPassed');\n\t\t\t}\n\n\t\t\treturn criteriaMet;\n\t\t},\n\n\t//Session End\n\t\tonWindowUnload: function() {\n\t\t\t$(window).off('unload', this._onWindowUnload);\n\n\t\t\tthis.stopListening();\n\t\t}\n\t\t\n\t}, Backbone.Events);\n\n\treturn AdaptStatefulSession;\n\n});\n\n","define('extensions/adapt-contrib-spoor/js/adapt-offlineStorage-scorm',[\n\t'coreJS/adapt',\n\t'./scorm',\n\t'coreJS/offlineStorage'\n], function(Adapt, scorm) {\n\n\t//SCORM handler for Adapt.offlineStorage interface.\n\n\t//Stores to help handle posting and offline uniformity\n\tvar temporaryStore = {};\n\tvar suspendDataStore = {};\n\tvar suspendDataRestored = false;\n\n\tAdapt.offlineStorage.initialize({\n\n\t\tget: function(name) {\n\t\t\tif (name === undefined) {\n\t\t\t\t//If not connected return just temporary store.\n\t\t\t\tif (this.useTemporaryStore()) return temporaryStore;\n\n\t\t\t\t//Get all values as a combined object\n\t\t\t\tsuspendDataStore = this.getCustomStates();\n\n\t\t\t\tvar data = _.extend(_.clone(suspendDataStore), {\n\t\t\t\t\tlocation: scorm.getLessonLocation(),\n\t\t\t\t\tscore: scorm.getScore(),\n\t\t\t\t\tstatus: scorm.getStatus(),\n\t\t\t\t\tstudent: scorm.getStudentName()\n\t\t\t\t});\n\n\t\t\t\tsuspendDataRestored = true;\n\t\t\t\t\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t//If not connected return just temporary store value.\n\t\t\tif (this.useTemporaryStore()) return temporaryStore[name];\n\n\t\t\t//Get by name\n\t\t\tswitch (name.toLowerCase()) {\n\t\t\t\tcase \"location\":\n\t\t\t\t\treturn scorm.getLessonLocation();\n\t\t\t\tcase \"score\":\n\t\t\t\t\treturn scorm.getScore();\n\t\t\t\tcase \"status\":\n\t\t\t\t\treturn scorm.getStatus();\n\t\t\t\tcase \"student\":\n\t\t\t\t\treturn scorm.getStudentName();\n\t\t\t\tdefault:\n\t\t\t\t\treturn this.getCustomState(name);\n\t\t\t}\n\t\t},\n\n\t\tset: function(name, value) {\n\t\t\t//Convert arguments to array and drop the 'name' parameter\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\tvar isObject = typeof name == \"object\";\n\n\t\t\tif (isObject) {\n\t\t\t\tvalue = name;\n\t\t\t\tname = \"suspendData\";\n\t\t\t}\n\n\t\t\tif (this.useTemporaryStore()) {\n\t\t\t\tif (isObject) {\n\t\t\t\t\ttemporaryStore = _.extend(temporaryStore, value);\n\t\t\t\t} else {\n\t\t\t\t\ttemporaryStore[name] = value;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tswitch (name.toLowerCase()) {\n\t\t\t\tcase \"interaction\":\n\t\t\t\t\treturn scorm.recordInteraction.apply(scorm, args);\n\t\t\t\tcase \"location\":\n\t\t\t\t\treturn scorm.setLessonLocation.apply(scorm, args);\n\t\t\t\tcase \"score\":\n\t\t\t\t\treturn scorm.setScore.apply(scorm, args);\n\t\t\t\tcase \"status\":\n\t\t\t\t\treturn scorm.setStatus.apply(scorm, args);\n\t\t\t\tcase \"student\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"suspenddata\":\n\t\t\t\tdefault:\n\t\t\t\t\tif (isObject) {\n\t\t\t\t\t\tsuspendDataStore = _.extend(suspendDataStore, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsuspendDataStore[name] = value;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar dataAsString = JSON.stringify(suspendDataStore);\n\t\t\t\t\treturn (suspendDataRestored) ? scorm.setSuspendData(dataAsString) : false;\n\t\t\t}\n\t\t},\n\n\t\tgetCustomStates: function() {\n\t\t\tvar isSuspendDataStoreEmpty = _.isEmpty(suspendDataStore);\n\t\t\tif (!isSuspendDataStoreEmpty && suspendDataRestored) return _.clone(suspendDataStore);\n\n\t\t\tvar dataAsString = scorm.getSuspendData();\n\t\t\tif (dataAsString === \"\" || dataAsString === \" \" || dataAsString === undefined) return {};\n\n\t\t\tvar dataAsJSON = JSON.parse(dataAsString);\n\t\t\tif (!isSuspendDataStoreEmpty && !suspendDataRestored) dataAsJSON = _.extend(dataAsJSON, suspendDataStore);\n\t\t\treturn dataAsJSON;\n\t\t},\n\n\t\tgetCustomState: function(name) {\n\t\t\tvar dataAsJSON = this.getCustomStates();\n\t\t\treturn dataAsJSON[name];\n\t\t},\n\t\t\n\t\tuseTemporaryStore: function() {\n\t\t\tvar cfg = Adapt.config.get('_spoor');\n\t\t\t\n\t\t\tif (!scorm.lmsConnected || (cfg && cfg._isEnabled === false)) return true;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t});\n\n});\n\n","define('extensions/adapt-contrib-spoor/js/adapt-contrib-spoor',[\n  'coreJS/adapt',\n  './scorm',\n  './adapt-stateful-session',\n  './adapt-offlineStorage-scorm'\n], function(Adapt, scorm, adaptStatefulSession) {\n\n  //SCORM session manager\n\n  var Spoor = _.extend({\n\n    _config: null,\n\n  //Session Begin\n\n    initialize: function() {\n      this.listenToOnce(Adapt, \"configModel:dataLoaded\", this.onConfigLoaded);\n      this.listenToOnce(Adapt, \"app:dataReady\", this.onDataReady);\n    },\n\n    onConfigLoaded: function() {\n      if (!this.checkConfig()) return;\n\n      this.configureAdvancedSettings();\n\n      scorm.initialize();\n\n      this.setupEventListeners();\n    },\n\n    onDataReady: function() {\n      adaptStatefulSession.initialize();\n    },\n\n    checkConfig: function() {\n      this._config = Adapt.config.has('_spoor') \n        ? Adapt.config.get('_spoor')\n        : false;\n\n      if (this._config && this._config._isEnabled !== false) return true;\n      \n      return false;\n    },\n\n    configureAdvancedSettings: function() {\n      if(this._config._advancedSettings) {\n        var settings = this._config._advancedSettings;\n\n        if(settings._showDebugWindow) scorm.showDebugWindow();\n\n        scorm.setVersion(settings._scormVersion || \"1.2\");\n\n        if(settings.hasOwnProperty(\"_suppressErrors\")) {\n          scorm.suppressErrors = settings._suppressErrors;\n        }\n\n        if(settings.hasOwnProperty(\"_commitOnStatusChange\")) {\n          scorm.commitOnStatusChange = settings._commitOnStatusChange;\n        }\n\n        if(settings.hasOwnProperty(\"_timedCommitFrequency\")) {\n          scorm.timedCommitFrequency = settings._timedCommitFrequency;\n        }\n\n        if(settings.hasOwnProperty(\"_maxCommitRetries\")) {\n          scorm.maxCommitRetries = settings._maxCommitRetries;\n        }\n\n        if(settings.hasOwnProperty(\"_commitRetryDelay\")) {\n          scorm.commitRetryDelay = settings._commitRetryDelay;\n        }\n      } else {\n        /**\n        * force use of SCORM 1.2 by default - some LMSes (SABA/Kallidus for instance) present both APIs to the SCO and, if given the choice,\n        * the pipwerks code will automatically select the SCORM 2004 API - which can lead to unexpected behaviour.\n        */\n        scorm.setVersion(\"1.2\");\n      }\n\n      /**\n      * suppress SCORM errors if 'nolmserrors' is found in the querystring\n      */\n      if(window.location.search.indexOf('nolmserrors') != -1) scorm.suppressErrors = true;\n    },\n\n    setupEventListeners: function() {\n      this._onWindowUnload = _.bind(this.onWindowUnload, this);\n      $(window).on('unload', this._onWindowUnload);\n    },\n\n  //Session End\n\n    onWindowUnload: function() {\n      scorm.finish();\n\n      $(window).off('unload', this._onWindowUnload);\n    }\n    \n  }, Backbone.Events);\n\n  Spoor.initialize();\n\n});\n\n","define('extensions/adapt-contrib-trickle/js/Defaults/DefaultTrickleConfig',[],function() {\n\n\tvar DefaultTrickleConfig = {\n\t\t_isEnabled: true,\n\t\t_scrollDuration: 500,\n\t\t_autoScroll: true,\n\t\t_onChildren: true,\n\t\t_button: {\n\t\t\t_isEnabled: true,\n\t\t\t_isFullWidth: true,\n\t\t\t_styleBeforeCompletion: \"hidden\",\n\t\t\t_styleAfterClick: \"hidden\",\n\t\t\t_autoHide: true,\n\t\t\ttext: \"Continue\",\n\t\t\t_component: \"trickle-button\"\n\t\t},\n\t\t_stepLocking: {\n\t        _isEnabled: true, \n\t        _isCompletionRequired: true,\n\t        _isLockedOnRevisit: false\n\t    },\n\t    _isInteractionComplete: false,\n\t    _scrollTo: \"@block +1\"\n\t};\n\n\treturn DefaultTrickleConfig;\n});\n","define('extensions/adapt-contrib-trickle/js/DataTypes/StructureType',[],function() {\n\t\n\tfunction StructureType(id, plural, level) {\n\t\tthis._id = id;\n\t\tthis._plural = plural;\n\t\tthis._level = level;\n\t\tStructureType.levels+=1;\n\t}\n\tStructureType.levels = 0;\n\n\tStructureType.prototype = {};\n\n\tStructureType.prototype.toString = function() {\n\t\treturn this._id;\n\t};\n\n\tStructureType.fromString = function(value) {\n\t\tswitch (value) {\n\t\tcase StructureType.Page._id: case StructureType.Page._plural:\n\t\t\treturn StructureType.Page;\n\t\tcase StructureType.Article._id: case StructureType.Article._plural:\n\t\t\treturn StructureType.Article;\n\t\tcase StructureType.Block._id: case StructureType.Block._plural:\n\t\t\treturn StructureType.Block;\n\t\tcase StructureType.Component._id: case StructureType.Component._plural:\n\t\t\treturn StructureType.Component;\n\t\t}\n\t};\n\n\tStructureType.fromInt = function(value) {\n\t\tswitch (value) {\n\t\tcase StructureType.Page._level: \n\t\t\treturn StructureType.Page;\n\t\tcase StructureType.Article._level: \n\t\t\treturn StructureType.Article;\n\t\tcase StructureType.Block._level: \n\t\t\treturn StructureType.Block;\n\t\tcase StructureType.Component._level: \n\t\t\treturn StructureType.Component;\n\t\t}\n\t};\n\n\tStructureType.Page = new StructureType(\"page\", \"pages\", 1);\n\tStructureType.Article = new StructureType(\"article\", \"articles\", 2);\n\tStructureType.Block = new StructureType(\"block\", \"blocks\", 3);\n\tStructureType.Component = new StructureType(\"component\", \"components\", 4);\n\n\treturn StructureType;\n\n});\n","define('extensions/adapt-contrib-trickle/js/Utility/Models',[\n    'coreJS/adapt',\n    '../DataTypes/StructureType'\n], function(Adapt, StructureType) {\n\n    var ModelUtilities = {\n        \n        /*\n        * Fetchs the sub structure of an id as a flattened array\n        *\n        *   Such that the tree:\n        *       { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }\n        *\n        *   will become the array (parent first = false):\n        *       [ c1, c2, b1, c3, c4, b2, a1, c5, c6, b3, a2 ]\n        *\n        *   or (parent first = true):\n        *       [ a1, b1, c1, c2, b2, c3, c4, a2, b3, c5, c6 ]\n        *\n        * This is useful when sequential operations are performed on the page/article/block/component hierarchy.\n        */\n        getDescendantsFlattened: function(id, parentFirst) {\n            var model = Adapt.findById(id);\n            if (model === undefined) return undefined;\n\n            var descendants = [];\n\n            var modelStructureType = StructureType.fromString(model.get(\"_type\"));\n            var isLastType = (modelStructureType._level === StructureType.levels);\n\n            if (isLastType) {\n                descendants.push(model);\n                return new Backbone.Collection(descendants);\n            }\n\n            var children = model.getChildren();\n\n            for (var i = 0, l = children.models.length; i < l; i++) {\n\n                var child = children.models[i];\n\n                var modelStructureType = StructureType.fromString(child.get(\"_type\"));\n                var isLastType = (modelStructureType._level === StructureType.levels);\n\n                if (isLastType) {\n\n                    descendants.push(child);\n\n                } else {\n\n                    var subDescendants = ModelUtilities.getDescendantsFlattened(child.get(\"_id\"), parentFirst);\n                    if (parentFirst == true) descendants.push(child);\n                    descendants = descendants.concat(subDescendants.models);\n                    if (parentFirst != true) descendants.push(child);\n\n                }\n\n            }\n\n            return new Backbone.Collection(descendants);\n        },\n\n        /*\n        * Returns a relative structural item from the Adapt hierarchy\n        *   \n        *   Such that in the tree:\n        *       { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }\n        *\n        *       findRelative(modelC1, \"@block +1\") = modelB2;\n        *       findRelative(modelC1, \"@component +4\") = modelC5;\n        *\n        */\n        findRelative: function(model, relativeString) {\n            //return a model relative to the specified one\n            var pageModel;\n            if (model.get(\"_type\") == \"page\") pageModel = model;\n            else pageModel = model.findAncestor(\"contentObjects\");\n\n            var pageId = pageModel.get(\"_id\");\n            var pageDescendants = ModelUtilities.getDescendantsFlattened(pageId).toJSON();\n\n            function parseRelative(relativeString) {\n                var type = relativeString.substr(0, _.indexOf(relativeString, \" \"));\n                var offset = parseInt(relativeString.substr(type.length));\n                type = type.substr(1);\n\n                /*RETURN THE TYPE AND OFFSET OF THE SCROLLTO\n                * \"@component +1\"  : \n                * {\n                *       type: \"component\",\n                *       offset: 1\n                * }\n                */\n                return { \n                    type: type,\n                    offset: offset\n                };\n            }\n\n            function getTypeOffset(model) {\n                var modelType = StructureType.fromString(model.get(\"_type\"));\n\n                //CREATE HASH FOR MODEL OFFSET IN PARENTS ACCORDING TO MODEL TYPE\n                var offsetCount = {};\n                for (var i = modelType._level - 1, l = 0; i > l; i--) {\n                    offsetCount[StructureType.fromInt(i)._id] = -1;\n                }\n\n                return offsetCount;\n            }\n\n            var pageDescendantIds = _.pluck(pageDescendants, \"_id\");\n\n            var modelId = model.get(\"_id\");\n            var fromIndex = _.indexOf( pageDescendantIds, modelId );\n\n            var typeOffset = getTypeOffset(model);\n            var relativeInstructions = parseRelative(relativeString);\n\n            for (var i = fromIndex +1, l = pageDescendants.length; i < l; i++) {\n                var item = pageDescendants[i];\n\n                if (!typeOffset[item._type]) typeOffset[item._type] = 0;\n\n                typeOffset[item._type]++;\n\n                if (typeOffset[relativeInstructions.type] >= relativeInstructions.offset) {\n                    if (!$(\".\"+item._id).is(\":visible\")) {\n                        //IGNORE VISIBLY HIDDEN ELEMENTS\n                        relativeInstructions.offset++;\n                        continue;\n                    }\n\n                    return Adapt.findById(item._id);\n                }\n            }\n\n            return undefined;\n        },\n\n        isLastStructureType: function(model) {\n            var modelStructureType = StructureType.fromString(model.get(\"_type\"));\n            var isLastType = (modelStructureType._level === StructureType.levels);\n            return isLastType;\n        }\n    };\n\n    return ModelUtilities;\n\n});\n\n","define('extensions/adapt-contrib-trickle/js/trickle-tutorPlugin',[\n    'coreJS/adapt', \n], function(Adapt) {\n\n    var TrickleTutorPlugin = _.extend({\n\n        onDataReady: function() {\n            this.setupEventListeners();\n        },\n\n        onStepLockingWaitCheck: function(model) {\n            if ( model.get(\"_type\") !== \"component\" || !model.get(\"_isQuestionType\") || !model.get(\"_canShowFeedback\")) return;\n\n            if (this._isTrickleWaiting) return;\n            Adapt.trigger(\"steplocking:wait\");\n            this._isTrickleWaiting = true;\n        },\n\n        onTutorOpened: function() {\n            if (this._isTrickleWaiting) return;\n            Adapt.trigger(\"steplocking:wait\");\n        },\n\n        onTutorClosed: function() {\n\n            if (!this._isTrickleWaiting) return;\n\n            Adapt.trigger(\"steplocking:unwait\");\n            this._isTrickleWaiting = false;\n        },\n\n        _isTrickleWaiting: false,\n\n        initialize: function() {\n            this.listenToOnce(Adapt, \"app:dataReady\", this.onDataReady);\n        },\n\n        setupEventListeners: function() {\n            this.listenTo(Adapt, \"steplocking:waitCheck\", this.onStepLockingWaitCheck);\n            this.listenTo(Adapt, \"tutor:open\", this.onTutorOpened);\n            this.listenTo(Adapt, \"tutor:closed\", this.onTutorClosed);\n        }\n\n    }, Backbone.Events);\n\n    TrickleTutorPlugin.initialize();\n\n})\n;\n","define('extensions/adapt-contrib-trickle/js/trickle-buttonView',[\n    'coreJS/adapt',\n    'coreViews/componentView'\n], function(Adapt, ComponentView) {\n\n    var completionAttribute = \"_isInteractionComplete\";\n\n    var TrickleButtonView = ComponentView.extend({\n\n        onEnabledChange: function(model, value) {\n            this.setDisabledState(!value);\n        },\n\n        onSteplockingCheckWait: function(parentModel) {\n            this.checkCurrentInteraction(parentModel);\n        },\n\n        onInteractionRequired: function(parentModel) {\n            this.showButton(parentModel); \n        },\n\n        onOnScreen: function() {\n            //show or hide the button when button is inview/outview\n            this.checkAutoHide( this.isOnScreen() );\n        },\n\n        onClick: function() {\n            if (!this.model.get(\"_isLocking\")) {\n                this.completeJump();\n            } else {\n                this.completeLock();\n            }\n        },\n\n        onRemove: function() {\n            this.undelegateEvents();\n            this.$el.remove();\n        },\n\n        events: {\n            \"click .trickle-button-inner > *\": \"onClick\",\n            \"onscreen\": \"onOnScreen\"\n        },\n\n        _isTrickleWaiting: false,\n\n        initialize: function() {\n            var trickleConfig = Adapt.config.get(\"_trickle\");\n            if (trickleConfig && trickleConfig._completionAttribute) completionAttribute = trickleConfig._completionAttribute;\n\n            this.addCustomClasses();\n            ComponentView.prototype.initialize.apply(this);\n\n            this.model.set(\"_isEnabled\", this.isInEnabledState());\n\n            this.checkAutoHide(this.isInVisibleState(), false);\n        },\n\n        addCustomClasses: function() {\n            if (!this.model.get(\"_trickle\")._button || !this.model.get(\"_trickle\")._button._className) return;\n            \n            this.$el.addClass(this.model.get(\"_trickle\")._button._className);\n        },\n\n        postRender: function() {\n            this.setDisabledState( !this.isInEnabledState() );\n\n            this.setReadyStatus();\n            this.setupEventListeners();\n        },\n\n        setDisabledState: function(bool) {\n            if (bool) this.$el.find(\".trickle-button-inner > *\").addClass(\"disabled\").attr(\"disabled\",\"disabled\");\n            else this.$el.find(\".trickle-button-inner > *\").removeClass(\"disabled\").removeAttr(\"disabled\");\n        },\n\n        setupEventListeners: function() {\n\n            var trickleConfig = this.model.get(\"_trickle\");\n            if (!trickleConfig._button._autoHide) this.$el.off(\"onscreen\");\n\n            this.listenTo(Adapt, \"trickle:interactionRequired\", this.onInteractionRequired);\n            this.listenTo(Adapt, \"steplocking:waitCheck\", this.onSteplockingCheckWait);\n            this.listenTo(this.model, \"change:_isEnabled\", this.onEnabledChange);\n            this.listenTo(this.model, \"change:_isVisible\", this.onVisibilityChange);\n            this.listenToOnce(Adapt, \"remove\", this.onRemove);\n            this.listenToOnce(Adapt, \"trickle:kill\", this.onRemove);\n        },\n\n        toggleLock: function(bool) {\n            if (!this.isStepLockingEnabled()) return;\n\n            var trickleConfig = this.model.get(\"_trickle\");\n\n            if (bool) {\n\n                this.$el.find('.component-inner').addClass(\"locking\");\n\n                this.model.set(\"_isLocking\", true);\n\n                this.steplockingWait();\n\n            } else {\n\n                this.$el.find('.component-inner').removeClass(\"locking\");\n\n                this.model.set(\"_isLocking\", false);\n\n                this.steplockingUnwait();\n            }\n        },\n\n        isStepLockingEnabled: function() {\n            var trickleConfig = this.model.get(\"_trickle\");\n            if (trickleConfig && trickleConfig._stepLocking && trickleConfig._stepLocking._isEnabled) {\n                return true;\n            }\n            return false;\n        },\n\n        steplockingWait: function() {\n            if (!this._isTrickleWaiting) Adapt.trigger(\"steplocking:wait\");\n            this._isTrickleWaiting = true;\n        },\n\n        steplockingUnwait: function() {\n            if (this._isTrickleWaiting) Adapt.trigger(\"steplocking:unwait\");\n            this._isTrickleWaiting = false;\n        },\n\n        checkCurrentInteraction: function(parentModel) {\n            if (parentModel.get(\"_id\") != this.model.get(\"_parentId\")) return;\n\n            var trickleConfig = this.model.get(\"_trickle\");\n\n            if (trickleConfig._isInteractionComplete) return;\n\n            this.model.set(\"_isEnabled\", this.isInEnabledState() );\n        },\n\n        showButton: function(parentModel) {\n            //check if the interaction required event is intended for this button\n            if (parentModel.get(\"_id\") != this.model.get(\"_parentId\")) return;\n\n            var trickleConfig = this.model.get(\"_trickle\");\n\n            if (trickleConfig._isInteractionComplete) return;\n\n            this.model.set(\"_isEnabled\",  this.isInEnabledState() );\n\n            this.toggleLock(true);\n\n            this.checkAutoHide(true, true);\n        },\n\n        checkAutoHide: function(bool, animate) {\n            \n            if (!this.isInVisibleState()) {\n                //override visible state if button should not be visible\n                bool = false;\n            }\n\n            this.model.set(\"_isVisible\", bool);\n\n            var trickleConfig = this.model.get(\"_trickle\");\n            if (!trickleConfig._button._autoHide) return;\n\n            if (this.model.get(\"_isHidden\") == bool) return;\n\n            this.model.set(\"_isHidden\", bool);\n\n            if (animate === false || Adapt.config.get('_disableAnimation')) {\n                //show or hide without animations\n                if (!bool) this.$('.component-inner').css(\"visibility\", \"hidden\");\n                else if (bool) this.$('.component-inner').css(\"visibility\", \"visible\");\n            } else {\n                //perform animation from visible<>hidden\n                if (bool) this.$('.component-inner').css(\"visibility\", \"visible\");\n                this.$('.component-inner').velocity(\"stop\", true).velocity({opacity: bool ? 1 : 0 }, {\n                    duration: 250,\n                    complete: _.bind(function() {\n                        if (!bool) this.$('.component-inner').css(\"visibility\", \"hidden\");\n                    }, this)\n                })\n            }\n            \n        },\n\n        isInEnabledState: function() {\n            var trickleConfig = this.model.get(\"_trickle\");\n\n            var _isEnabled = true;\n\n            var isEnabledBeforeCompletion = false;\n            //Check to see if autohide component should always be visible or if it has a precompletion hidden state\n            if (trickleConfig._button._styleBeforeCompletion == \"visible\") {\n                isEnabledBeforeCompletion = (!trickleConfig._stepLocking._isEnabled || !trickleConfig._stepLocking._isCompletionRequired);\n            }\n\n            var isEnabledAfterClick = (trickleConfig._button._styleAfterClick != \"hidden\" && trickleConfig._button._styleAfterClick != \"disabled\");\n\n            var parentModel = Adapt.findById(this.model.get(\"_parentId\"));\n            var isComplete = parentModel.get(completionAttribute);\n            var isClicked = trickleConfig._isInteractionComplete;\n\n            var isBeforeCompletionEnabled = (!isComplete && !isClicked && isEnabledBeforeCompletion);\n            var isAfterCompletionEnabled = (isClicked && isEnabledAfterClick);\n            var isInInteractionEnabled = (isComplete && !isClicked);\n\n            _isEnabled = isBeforeCompletionEnabled || isAfterCompletionEnabled || isInInteractionEnabled;\n\n            return _isEnabled;\n        },\n\n        isInVisibleState: function() {\n            var trickleConfig = this.model.get(\"_trickle\");\n\n            var _isVisible = true;\n\n            var isVisibleBeforeCompletion = true;\n            //Check to see if autohide component should always be visible or if it has a precompletion hidden state\n            if (trickleConfig._button._styleBeforeCompletion == \"hidden\") {\n                isVisibleBeforeCompletion = (trickleConfig._button._styleBeforeCompletion != \"hidden\");\n            }\n\n            var isVisibleAfterClick = (trickleConfig._button._styleAfterClick != \"hidden\");\n\n            var parentModel = Adapt.findById(this.model.get(\"_parentId\"));\n            var isComplete = parentModel.get(completionAttribute);\n            var isClicked = trickleConfig._isInteractionComplete;\n\n            var isOnScreen = true;\n            if (trickleConfig._button._autoHide) {\n                isOnScreen = this.isOnScreen();\n            }\n\n            var isBeforeCompletionVisible = (!isComplete && !isClicked && isVisibleBeforeCompletion && isOnScreen);\n            var isInInteractionVisible = (isComplete && !isClicked && isOnScreen);\n            var isAfterCompletionVisible = (isClicked && isVisibleAfterClick && isOnScreen);\n\n            _isVisible = isBeforeCompletionVisible || isAfterCompletionVisible || isInInteractionVisible;\n\n\n            return _isVisible;\n\n        },\n\n        isOnScreen: function() {\n            var onscreen = false;\n            var measurements = this.$el.onscreen();\n            var parent = this.$el.offsetParent();\n            var isParentHtml = parent.is(\"html\");\n            if (!isParentHtml && measurements.bottom > -(this.$(\".component-inner\").outerHeight()*2)) {\n                onscreen = true;\n            }\n            return onscreen;\n        },\n\n        completeJump: function() {\n\n            var trickleConfig = this.model.get(\"_trickle\");\n            trickleConfig._isInteractionComplete = true;\n\n            this.updateState();\n\n            this.scrollTo();\n        },\n\n        updateState: function() {\n\n            var trickleConfig = this.model.get(\"_trickle\");\n\n            switch (trickleConfig._button._styleAfterClick) {\n            case \"disabled\": case \"hidden\":\n                this.model.set(\"_isEnabled\", this.isInEnabledState() );\n                this.$el.off(\"onscreen\");\n                this.stopListening();\n                break;\n            case \"scroll\":\n                this.model.set(\"_isEnabled\", this.isInEnabledState() );\n                break;\n            }\n\n            this.checkAutoHide(true, true);\n        },\n\n        scrollTo: function() {\n            var trickleConfig = this.model.get(\"_trickle\");\n            var scrollTo = trickleConfig._scrollTo;\n            var parentModel = Adapt.findById(this.model.get(\"_parentId\"));\n            Adapt.trigger(\"trickle:relativeScrollTo\", parentModel, scrollTo);\n        },\n\n        completeLock: function() {\n\n            var trickleConfig = this.model.get(\"_trickle\");\n            trickleConfig._isInteractionComplete = true;\n\n            this.toggleLock(false);\n\n            //as this is an 'out-of-course' component, \n            //we must manually ask trickle to consider the completion of its parent (possibly for a second time)\n            var parentModel = Adapt.findById(this.model.get(\"_parentId\"));\n            Adapt.trigger(\"trickle:interactionComplete\", parentModel);\n            \n            this.updateState();\n        }\n\n    });\n\n    Adapt.register(\"trickle-button\", TrickleButtonView);\n\n    return TrickleButtonView;\n});\n\n","define('extensions/adapt-contrib-trickle/js/Defaults/FullWidthButtonConstants',[],function() {\n\n\tvar FullWidthButtonConstants = {\n\t\t_stepLocking: {\n\t\t\t_isEnabled: true\n\t\t}\n\t};\n\t\n\treturn FullWidthButtonConstants;\n});\n","define('extensions/adapt-contrib-trickle/js/trickle-buttonModel',[\n    'coreModels/adaptModel',\n    './Defaults/FullWidthButtonConstants'\n], function(AdaptModel, FullWidthButtonConstants) {\n\n    var TrickleButtonModel = AdaptModel.extend({\n        \n        initialize: function(options) {\n            if (options.trickleConfig === undefined) return;\n            if (options.parentModel === undefined) return;\n\n            var parentModel = options.parentModel;\n            var trickleConfig = options.trickleConfig;\n\n            var isFullWidth = (trickleConfig._button._isFullWidth);\n            if (isFullWidth) {\n                //setup configuration with FullWidth type constants\n                $.extend(true, trickleConfig, FullWidthButtonConstants);\n            }\n\n            this.setupButtonText(trickleConfig);\n\n            this.set({\n                _id: \"trickle-button-\"+parentModel.get(\"_id\"),\n                _type: \"component\",\n                _component: \"trickle-button\",\n                //turn off accessibility state for button component\n                _classes: \"no-state\" + (isFullWidth ? \" trickle-full-width\" : \"\"),\n                _layout: \"full\",\n                _parentId: parentModel.get(\"_id\"),\n                _parentType: parentModel.get(\"_type\"),\n                _parentComponent: parentModel.get(\"_component\"),\n                _trickle: trickleConfig,\n                _isVisible: true,\n                _isHidden: false,\n                _isAvailable: true,\n                _isEnabled: true,\n                _isLocking: trickleConfig._isLocking,\n                _isComplete: trickleConfig._isInteractionComplete,\n                _isInteractionComplete: trickleConfig._isInteractionComplete,\n                _index: trickleConfig._index\n            });\n\n        },\n\n        setupButtonText: function(trickleConfig) {\n            if (trickleConfig._isLastItem) {\n                //Apply final text to last button\n                if (trickleConfig._button && trickleConfig._button.finalText) {\n                    var previousText = trickleConfig._button.text;\n\n                    trickleConfig._button.text = trickleConfig._button.finalText,\n                    trickleConfig._button.previousText = previousText;\n                }\n            } else {\n                //Reset button to previous text\n                if (trickleConfig && trickleConfig._button.previousText) {\n                    trickleConfig._button.text = trickleConfig._button.previousText;\n                    trickleConfig._button.previousText = null;\n                }\n            }\n        }\n\n    });\n\n    return TrickleButtonModel;\n\n});\n","define('extensions/adapt-contrib-trickle/js/trickle-buttonPlugin',[\n    'coreJS/adapt',\n    './trickle-buttonView',\n    './trickle-buttonModel'\n], function(Adapt, TrickleButtonView, TrickleButtonModel) {\n\n    var completionAttribute = \"_isInteractionComplete\";\n\n    var TrickleButtonPlugin = {\n        \n        onInteractionInitialize: function(model) {\n            var trickleConfig = Adapt.config.get(\"_trickle\");\n            if (trickleConfig && trickleConfig._completionAttribute) completionAttribute = trickleConfig._completionAttribute;\n\n            TrickleButtonPlugin.createButton(model);\n        },\n\n        createButton: function(model) {\n            var trickleConfig = model.get(\"_trickle\");\n            if (!trickleConfig) return false;\n\n            if (!TrickleButtonPlugin.shouldRenderButton(model, trickleConfig)) return;\n            TrickleButtonPlugin.buildAndAppendButton(model, trickleConfig);\n        },\n\n        shouldRenderButton: function(model, trickleConfig) {\n            if (!trickleConfig._button._isEnabled) return false;\n            if (!trickleConfig._button._component == \"trickle-button\") return false;\n\n            return true;\n        },\n\n        buildAndAppendButton: function(model, trickleConfig) {\n            var $containerModelElement = $(\".\" + trickleConfig._id);\n\n            var buttonModel = new TrickleButtonModel({ \n                trickleConfig: trickleConfig, \n                parentModel: model \n            });\n\n            var buttonView = new TrickleButtonView({ \n                model: buttonModel, \n                nthChild: \"additional\" \n            });\n\n            $containerModelElement.append( buttonView.$el );\n        }\n    };\n\n    Adapt.on(\"trickle:interactionInitialize\", TrickleButtonPlugin.onInteractionInitialize);\n\n    return TrickleButtonPlugin;\n});\n","//https://github.com/cgkineo/jquery.resize 2015-08-13\n\n(function() {\n\n  if ($.fn.off.elementResizeOriginalOff) return;\n\n\n  var orig = $.fn.on;\n  $.fn.on = function () {\n    if (arguments[0] !== \"resize\") return $.fn.on.elementResizeOriginalOn.apply(this, _.toArray(arguments));\n    if (this[0] === window) return $.fn.on.elementResizeOriginalOn.apply(this, _.toArray(arguments));\n\n    addResizeListener.call(this, (new Date()).getTime());\n\n    return $.fn.on.elementResizeOriginalOn.apply(this, _.toArray(arguments));\n  };\n  $.fn.on.elementResizeOriginalOn = orig;\n  var orig = $.fn.off;\n  $.fn.off = function () {\n    if (arguments[0] !== \"resize\") return $.fn.off.elementResizeOriginalOff.apply(this, _.toArray(arguments));\n    if (this[0] === window) return $.fn.off.elementResizeOriginalOff.apply(this, _.toArray(arguments));\n\n    removeResizeListener.call(this, (new Date()).getTime());\n\n    return $.fn.off.elementResizeOriginalOff.apply(this, _.toArray(arguments));\n  };\n  $.fn.off.elementResizeOriginalOff = orig;\n\n  var expando = $.expando;\n\n  //element + event handler storage\n  var resizeObjs = {};\n\n  //jQuery element + event handler attachment / removal\n  var addResizeListener = function(data) {\n      resizeObjs[data.guid + \"-\" + this[expando]] = { \n        data: data, \n        $element: $(this) \n      };\n  };\n\n  var removeResizeListener = function(data) {\n    try { \n      delete resizeObjs[data.guid + \"-\" + this[expando]]; \n    } catch(e) {\n\n    }\n  };\n\n  function checkLoopExpired() {\n    if ((new Date()).getTime() - loopData.lastEvent > 500) {\n      stopLoop()\n      return true;\n    }\n  }\n\n  function resizeLoop () {\n    if (checkLoopExpired()) return;\n\n    var resizeHandlers = getEventHandlers(\"resize\");\n\n    if (resizeHandlers.length === 0) {\n      //nothing to resize\n      stopLoop();\n      resizeIntervalDuration = 500;\n      repeatLoop();\n    } else {\n      //something to resize\n      stopLoop();\n      resizeIntervalDuration = 250;\n      repeatLoop();\n    }\n\n    if  (resizeHandlers.length > 0) {\n      var items = resizeHandlers;\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        triggerResize(item);\n      }\n    }\n\n  }\n\n  function getEventHandlers(eventName) {\n    var items = [];\n    \n    switch (eventName) {\n    case \"resize\":\n      for (var k in resizeObjs) {\n        items.push(resizeObjs[k]);\n      }\n      break;\n    }\n\n    return items;\n  }\n\n  function getDimensions($element) {\n      var height = $element.outerHeight();\n      var width = $element.outerWidth();\n\n      return {\n        uniqueMeasurementId: height+\",\"+width\n      };\n  }\n\n  function triggerResize(item) {\n    var measure = getDimensions(item.$element);\n    //check if measure has the same values as last\n    var isFirstRun = false;\n    if (item._resizeData === undefined) isFirstRun = true;\n    if (item._resizeData !== undefined && item._resizeData === measure.uniqueMeasurementId) return;\n    item._resizeData = measure.uniqueMeasurementId;\n    if (isFirstRun) return;\n    \n    //make sure to keep listening until no more resize changes are found\n    loopData.lastEvent = (new Date()).getTime();\n    \n    item.$element.trigger('resize');\n  }\n\n\n  //checking loop interval duration\n  var resizeIntervalDuration = 250;\n\n  var loopData = {\n    lastEvent: 0,\n    interval: null\n  };\n\n  //checking loop start and end\n  function startLoop() {\n    loopData.lastEvent = (new Date()).getTime();\n    if (loopData.interval !== null) {\n      stopLoop();\n    }\n    loopData.interval = setTimeout(resizeLoop, resizeIntervalDuration);\n  }\n\n  function repeatLoop() {\n    if (loopData.interval !== null) {\n      stopLoop();\n    }\n    loopData.interval = setTimeout(resizeLoop, resizeIntervalDuration);\n  }\n\n  function stopLoop() {\n    clearInterval(loopData.interval);\n    loopData.interval = null;\n  }\n\n  $('body').on(\"mousedown mouseup keyup keydown\", startLoop);\n  $(window).on(\"resize\", startLoop);\n\n\n})();\n\ndefine(\"extensions/adapt-contrib-trickle/js/lib/jquery.resize\", function(){});\n\n","define('extensions/adapt-contrib-trickle/js/adapt-contrib-trickle',[\n    'coreJS/adapt',\n    './Defaults/DefaultTrickleConfig',\n    './Utility/Models',\n    './trickle-tutorPlugin',\n    './trickle-buttonPlugin',\n    './lib/jquery.resize'\n], function(Adapt, DefaultTrickleConfig, Models) {\n\n    var completionAttribute = \"_isInteractionComplete\";\n\n    var Trickle = _.extend({\n\n        onDataReady: function() {\n            var trickleConfig = Adapt.config.get(\"_trickle\");\n            if (trickleConfig && trickleConfig._completionAttribute) completionAttribute = trickleConfig._completionAttribute;\n\n            this.setupEventListeners();\n        },\n\n        onPagePreRender: function(view) {\n            this.initializePage(view);\n        },\n\n        onArticlePreRender: function(view) {\n            this.checkApplyTrickleToChildren( view.model );\n        },\n\n        onPagePostRender: function(view) {\n            this.resizeBodyToCurrentIndex();\n        },\n\n        onArticleAndBlockPostRender: function(view) {\n            this.setupStep( view.model );\n        },\n\n        onPageReady: function(view) {\n            this.initializeStep();\n            this.resizeBodyToCurrentIndex();\n            this._listenToResizeEvent = true;\n            this._isPageReady = true;\n            Adapt.trigger(\"trickle:pageReady\");\n        },\n\n        onAnyComplete: function(model, value, isPerformingCompletionQueue) {\n            this.queueOrExecuteCompletion(model, value, isPerformingCompletionQueue);\n        },\n\n        onStepUnlockWait: function() {\n            this._waitForUnlockRequestsCount++;\n        },\n\n        onStepUnlockUnwait: function() {\n            this._waitForUnlockRequestsCount--;\n            if (this._waitForUnlockRequestsCount < 0) this._waitForUnlockRequestsCount = 0;\n\n            if (this._isFinished) return;\n\n            var descendant = this.getCurrentStepModel();\n            this.checkStepComplete(descendant);\n        },\n\n        onWrapperResize: function() {\n            if (!this._listenToResizeEvent) {\n                return;\n            }\n\n            this.resizeBodyToCurrentIndex();\n            this._listenToResizeEvent = true;\n        },\n\n        onRemove: function(view) {\n            this.endTrickle();\n        },\n\n\n        model: new Backbone.Model({}),\n\n        _listenToResizeEvent: false,\n        _isPageInitialized: false,\n        _isPageReady: false,\n        _isFinished: false,\n        _currentStepIndex: 0,\n        _descendantsChildrenFirst: null,\n        _descendantsParentFirst: null,\n        _pageView: null,\n        _isTrickleOn: false,\n\n        initialize: function() {\n            this.listenToOnce(Adapt, \"app:dataReady\", this.onDataReady);\n        },\n\n        setupEventListeners: function() {\n            this._onWrapperResize = _.bind(Trickle.onWrapperResize, Trickle);\n            $(\"#wrapper\").on('resize', this._onWrapperResize );\n\n            this.listenTo(Adapt, \"remove\", this.onRemove);\n            this.listenTo(Adapt, \"pageView:preRender\", this.onPagePreRender);\n            this.listenTo(Adapt, \"pageView:postRender\", this.onPagePostRender);\n            this.listenTo(Adapt, \"pageView:ready\", this.onPageReady);\n\n            this.listenTo(Adapt, \"articleView:preRender\", this.onArticlePreRender);\n            this.listenTo(Adapt, \"blockView:postRender articleView:postRender\", this.onArticleAndBlockPostRender);\n\n            this.listenTo(Adapt.articles, \"change:\"+completionAttribute, this.onAnyComplete);\n            this.listenTo(Adapt.blocks, \"change:\"+completionAttribute, this.onAnyComplete);\n            this.listenTo(Adapt.components, \"change:\"+completionAttribute, this.onAnyComplete);           \n\n            this.listenTo(Adapt, \"trickle:interactionComplete\", this.checkStepComplete);\n\n            this.listenTo(Adapt, \"steplocking:wait\", this.onStepUnlockWait);\n            this.listenTo(Adapt, \"steplocking:unwait\", this.onStepUnlockUnwait);\n\n            this.listenTo(Adapt, \"trickle:relativeScrollTo\", this.relativeScrollTo);\n\n            this.listenTo(Adapt, \"trickle:kill\", this.endTrickle);\n        },\n\n        initializePage: function(view) {\n            var pageId = view.model.get(\"_id\");\n\n            var pageConfig = Adapt.course.get(\"_trickle\");\n            if (pageConfig && pageConfig._isEnabled === false) return;\n\n            this._descendantsChildrenFirst =  Models.getDescendantsFlattened(pageId);\n            this._descendantsParentFirst = Models.getDescendantsFlattened(pageId, true);\n            this._currentStepIndex = 0;\n            this._isFinished = false;\n            this._listenToResizeEvent = false;\n            this._pageView = view;\n\n            this.checkResetChildren();\n\n            this.initializeStepUnlockWait();\n\n            this._isPageInitialized = true;\n\n        },\n\n        checkResetChildren: function() {\n            var descendantsChildrenFirst = this._descendantsChildrenFirst;\n            for (var i = 0, model; model = descendantsChildrenFirst.models[i++];) {\n                this.checkResetModel(model);\n            }\n        },\n\n        checkResetModel: function(model) {\n            var trickleConfig = this.getModelTrickleConfig(model);\n            if (!trickleConfig) return;\n            if (trickleConfig._onChildren) return;\n\n            if (!trickleConfig._stepLocking || !trickleConfig._stepLocking._isEnabled == true) return;      \n            \n            if (model.get(completionAttribute) && !trickleConfig._isLocking) trickleConfig._isInteractionComplete = true;\n\n            if (!trickleConfig._isInteractionComplete) {\n                \n                trickleConfig._isLocking = true;\n\n            }\n\n            if (trickleConfig._stepLocking._isLockedOnRevisit || \n                (trickleConfig._stepLocking._isCompletionRequired && !model.get(completionAttribute))) {\n\n                trickleConfig._isInteractionComplete = false;\n                trickleConfig._isLocking = true;\n\n            }\n\n        },\n\n        getModelTrickleConfig: function(model) {\n\n            function initializeModelTrickleConfig(model, parent) {\n                var trickleConfig = model.get(\"_trickle\");\n\n                var courseConfig = Adapt.course.get(\"_trickle\");\n                if (courseConfig && courseConfig._isEnabled === false) return false;\n\n                var trickleConfig = $.extend(true, \n                    {}, \n                    DefaultTrickleConfig, \n                    trickleConfig,\n                    { \n                        _id: model.get(\"_id\"), \n                        _areDefaultsSet: true,\n                        _index: parent.getModelPageIndex(model)\n                    }\n                );\n\n                if (model.get(\"_type\") != \"article\") {\n                    trickleConfig._onChildren = false;\n                }\n\n                var isLastPageItem = ( trickleConfig._index == parent._descendantsChildrenFirst.length - 2 );\n                if (isLastPageItem && model.get(\"_type\") != \"article\") {\n                    return false;\n                }\n\n                model.set(\"_trickle\", trickleConfig);\n\n                return true;\n            }\n\n            var trickleConfig = model.get(\"_trickle\");\n            if (trickleConfig === undefined) return false;\n\n            //if has been initialized already, return;\n            if (trickleConfig._areDefaultsSet) return trickleConfig;\n\n            if (!initializeModelTrickleConfig(model, this)) return false;\n            \n            return model.get(\"_trickle\");\n        },\n\n        getModelPageIndex: function(model) {\n            var descendants = this._descendantsChildrenFirst.toJSON();\n            var pageDescendantIds = _.pluck(descendants, \"_id\");\n\n            var id = model.get(\"_id\");\n            var index = _.indexOf( pageDescendantIds, id );\n\n            return index;\n        },\n\n        initializeStepUnlockWait: function() {\n            this._waitForUnlockRequestsCount = 0;\n        },\n\n        checkApplyTrickleToChildren: function(model) {\n            if (model.get(\"_type\") != \"article\") return;\n\n            var trickleConfig = this.getModelTrickleConfig(model);\n            if (!trickleConfig) return;\n            if (!trickleConfig._onChildren) return;\n\n            this.applyTrickleToChildren(model, trickleConfig);\n        },\n\n        applyTrickleToChildren: function(model, parentTrickleConfig) {\n            var children = model.getChildren().models;\n            for (var i = 0, l = children.length; i < l; i++) {\n\n                var child = children[i];\n                var childTrickleConfig = child.get(\"_trickle\");\n\n                var isLastItem = (i == l - 1);\n\n                var isEnabled = true;\n                if (childTrickleConfig) {\n                    if (childTrickleConfig._isEnabled === false) {\n                        isEnabled = false;\n                    }\n                }\n                if (parentTrickleConfig) {\n                    if (parentTrickleConfig._isEnabled === false) {\n                        isEnabled = false;\n                    }\n                }\n\n                var trickleConfig = $.extend(true, \n                    {}, \n                    parentTrickleConfig, \n                    childTrickleConfig, \n                    { \n                        _id: child.get(\"_id\"),\n                        _onChildren: false,\n                        _isEnabled: isEnabled,\n                        _isLastItem: isLastItem,\n                        _index: this.getModelPageIndex(child)\n                    }\n                );\n\n                var isLastPageItem = ( trickleConfig._index == this._descendantsChildrenFirst.length - 2 );\n                if (isLastPageItem) {\n                    continue;\n                }\n\n                child.set(\"_trickle\", trickleConfig);\n\n                this.checkResetModel(child);\n                \n            }\n        },\n\n        resizeBodyToCurrentIndex: function() {\n            if (!this._isTrickleOn) return;\n            \n            if (this._isFinished) return this.showElements();\n\n            this._listenToResizeEvent = false;\n\n            this.showElements();\n\n            var id = this.getCurrentStepModel().get(\"_id\");\n            var $element = $(\".\" + id);\n\n            if ($element.length === 0) {\n                return;\n            }\n\n            var elementOffset = $element.offset();\n            var elementBottomOffset = elementOffset.top + $element.outerHeight();\n\n            $('body').css(\"height\", elementBottomOffset + \"px\");\n        },\n\n        showElements: function() {\n            if (!this._descendantsParentFirst) return;\n\n            var model = this.getCurrentStepModel();\n            var ancestors = this._descendantsParentFirst.models;\n            var ancestorIds = _.pluck(this._descendantsParentFirst.toJSON(), \"_id\");\n\n            var showToId;\n            if (model !== undefined) {\n                //Not at end of trickle\n                showToId = model.get(\"_id\");\n\n                var isLastType = Models.isLastStructureType(model);\n\n                if (!isLastType) {\n                    //If current step model is not a component type:\n                    //then show components for the selected parent\n                    var currentAncestorIndex = _.indexOf(ancestorIds, showToId);\n                    var ancestorChildComponents = ancestors[currentAncestorIndex].findDescendants(\"components\");\n\n                    showToId = ancestorChildComponents.models[ancestorChildComponents.models.length-1].get(\"_id\");\n                }\n\n            } else {\n                //At end, show all ids\n                showToId = ancestors[ancestors.length -1].get(\"_id\");\n            }\n            \n            \n            var showToIndex = _.indexOf(ancestorIds, showToId);\n\n            for (var i = 0, l = ancestors.length; i < l; i++) {\n                var itemModel = ancestors[i];\n                if (i <= showToIndex) {\n                    itemModel.set(\"_isVisible\", true, { pluginName: \"trickle\" });\n                } else {\n                    itemModel.set(\"_isVisible\", false, { pluginName: \"trickle\" });\n                }\n            }\n            \n        },\n\n        getCurrentStepModel: function() {\n            if (!this._descendantsChildrenFirst) return;\n\n            return this._descendantsChildrenFirst.models[this._currentStepIndex];\n        },\n\n        setupStep: function(model) {\n            var trickleConfig = this.getModelTrickleConfig(model)\n            if (!trickleConfig) return;\n            if (!trickleConfig._isEnabled) return;\n            if (trickleConfig._onChildren) return;\n\n            var isStepLocking = this.isModelStepLocking(model);\n            trickleConfig._isStepLocking = isStepLocking;\n\n            Adapt.trigger(\"trickle:interactionInitialize\", model);\n        },\n\n        initializeStep: function() {\n            if (this._isFinished) return;\n            this.initializeStepUnlockWait();\n\n            if (this.hasCurrentStepLock()) {\n                this.startTrickle();\n            } else {\n                this.endTrickle();\n            }\n        },\n\n        hasCurrentStepLock: function() {\n            var currentIndex = this._currentStepIndex;\n            var descendants = this._descendantsChildrenFirst.models;\n            for (var i = currentIndex, l = descendants.length; i < l; i++) {\n                var descendant = descendants[i];\n\n                if (!this.isModelStepLocking(descendant)) continue;\n\n                this._currentStepIndex = i;\n                \n\n                return true;\n            }\n\n            return false;\n        },\n\n        isModelStepLocking: function(model) {\n            var trickleConfig = this.getModelTrickleConfig(model)\n            if (!trickleConfig) return false;\n            if (trickleConfig._onChildren) return false;\n\n            if (trickleConfig._isEnabled === false) return false;\n            \n            if (!trickleConfig._stepLocking || !trickleConfig._stepLocking._isEnabled) return false;\n            \n            if (trickleConfig._isLocking) return true;\n            if (trickleConfig._isInteractionComplete) return false;\n\n            var isComplete = model.get(completionAttribute);\n            if (isComplete !== undefined) return !isComplete;\n\n            return true;\n        },\n\n        startTrickle: function() {\n            this._isTrickleOn = true;\n            $(\"html\").addClass(\"trickle\");\n            Adapt.trigger(\"steplocking:waitInitialize\");\n            this.resizeBodyToCurrentIndex();\n            this._listenToResizeEvent = true;\n        },\n\n        endTrickle: function() {\n            this._currentStepIndex = -1;\n            this._isFinished = true;\n            $(\"body\").css(\"height\", \"\");\n            $(\"html\").removeClass(\"trickle\");\n            this._pageView = null;\n            this.resizeBodyToCurrentIndex();\n            this._isPageReady = false;\n            this._listenToResizeEvent = true;\n            this._isTrickleOn = false;\n        },\n\n        //completion reorder and processing\n        _completionQueue: [],\n        queueOrExecuteCompletion: function(model, value, isPerformCompletionQueue) {\n            if (value === false) return;    \n\n            if (isPerformCompletionQueue !== true) {\n                //article, block and component completion trigger in a,b,c order need in c,b,a order\n                //otherwise block completion events will occur before component completion events\n                \n                var isLastType = Models.isLastStructureType(model);\n\n                if (!isLastType) {\n                    //defer completion event handling if not at component level\n                    return this._completionQueue.push({\n                        model: model,\n                        value: value    \n                    });\n                } else {\n                    //if at component level, handle completion queue events after component completion is handled\n                    if (this._isPageReady) {\n                        _.defer(_.bind(this.performCompletionQueue, this));\n                    } else {\n                        this.listenToOnce(Adapt, \"trickle:pageReady\", function(){                            \n                            this.performCompletionQueue();\n                        });\n                    }\n                }\n            }\n\n            if (this._isPageReady) {\n                Adapt.trigger(\"steplocking:waitCheck\", model);\n                this.checkStepComplete(model);\n            } else {                \n                this.listenToOnce(Adapt, \"trickle:pageReady\", function(){                    \n                    Adapt.trigger(\"steplocking:waitCheck\", model);\n                    this.checkStepComplete(model);\n                });\n            }\n        },\n\n        performCompletionQueue: function() {\n            while (this._completionQueue.length > 0) {\n                var item = this._completionQueue.pop();\n                this.queueOrExecuteCompletion(item.model, item.value, true);\n            }\n        },\n\n        checkStepComplete: function(model) {\n            if (this._isFinished) return;\n\n            var currentModel = this.getCurrentStepModel();\n\n            //if the model does not match the current trickle item then break\n            if (model.get(\"_id\") != currentModel.get(\"_id\")) return;\n\n            var trickleConfig = this.getModelTrickleConfig(model);\n            if (!trickleConfig) return;\n            \n            //if plugins need to present before the interaction then break\n            if (this.isStepUnlockWaiting()) return;\n            \n            //if completion is required and item is not yet complete then break\n            if (trickleConfig._stepLocking._isCompletionRequired && !model.get(completionAttribute)) return;\n\n            Adapt.trigger(\"trickle:interactionRequired\", model);\n            \n            //if plugins need to present before the next step occurs then break\n            if (this.isStepUnlockWaiting()) return;\n\n            //set interaction complete\n            trickleConfig._isLocking = false;\n            trickleConfig._isInteractionComplete = true;\n\n            this.stepComplete(model);\n        },\n\n        stepComplete: function(model) {\n            this.initializeStep();\n\n            Adapt.trigger('device:resize');\n\n            this.scrollToStep(model);\n        },\n\n        scrollToStep: function(model) {\n            var trickleConfig = this.getModelTrickleConfig(model);\n            if (trickleConfig._autoScroll === false) return;\n\n            var scrollTo = trickleConfig._scrollTo;\n            \n            //Allows trickle to scroll to a sibling / cousin component relative to the current trickle item\n            this.relativeScrollTo( model, scrollTo );\n        },\n\n        isStepUnlockWaiting: function() {\n            return this._waitForUnlockRequestsCount > 0;\n        },\n        \n        relativeScrollTo: function(model, scrollTo) {\n            if (scrollTo === undefined) scrollTo = \"@block +1\";\n\n            var scrollToId = \"\";\n            switch (scrollTo.substr(0,1)) {\n            case \"@\":\n                //NAVIGATE BY RELATIVE TYPE\n                \n                //Allows trickle to scroll to a sibling / cousin component relative to the current trickle item\n                var relativeModel = Models.findRelative(model, scrollTo);\n                \n                if (relativeModel === undefined) return;\n                scrollToId = relativeModel.get(\"_id\");\n\n                break;\n            case \".\":\n                //NAVIGATE BY CLASS\n                scrollToId = scrollTo.substr(1, scrollTo.length-1);\n                break;\n            default: \n                scrollToId = scrollTo;\n            }\n\n            if (scrollToId == \"\") return;\n            \n            var duration = model.get(\"_trickle\")._scrollDuration || 500;\n            _.delay(function() {\n                Adapt.scrollTo(\".\" + scrollToId, { duration: duration });\n            }, 250);\n        }\n        \n    }, Backbone.Events);\n\n    Trickle.initialize();\n\n    return Trickle;\n\n})\n;\n","define('extensions/adapt-contrib-tutor/js/adapt-contrib-tutor',[\n    'coreJS/adapt'\n],function(Adapt) {\n\n    Adapt.on('questionView:showFeedback', function(view) {\n\n        var alertObject = {\n            title: view.model.get(\"feedbackTitle\"),\n            body: view.model.get(\"feedbackMessage\")\n        };\n\n        if (view.model.has('_isCorrect')) {\n            // Attach specific classes so that feedback can be styled.\n            if (view.model.get('_isCorrect')) {\n                alertObject._classes = 'correct';\n            } else {\n                if (view.model.has('_isAtLeastOneCorrectSelection')) {\n                    // Partially correct feedback is an option.\n                    alertObject._classes = view.model.get('_isAtLeastOneCorrectSelection')\n                        ? 'partially-correct'\n                        : 'incorrect';\n                } else {\n                    alertObject._classes = 'incorrect';\n                }\n            }\n        }\n\n        Adapt.once(\"notify:closed\", function() {\n            Adapt.trigger(\"tutor:closed\");\n        });\n\n        Adapt.trigger('notify:popup', alertObject);\n\n        Adapt.trigger('tutor:opened');\n    });\n\n});\n\n","define('components/adapt-contrib-accordion/js/adapt-contrib-accordion',['require','coreViews/componentView','coreJS/adapt'],function(require) {\n\n    var ComponentView = require('coreViews/componentView');\n    var Adapt = require('coreJS/adapt');\n\n    var Accordion = ComponentView.extend({\n\n        events: {\n            'click .accordion-item-title': 'toggleItem'\n        },\n\n        preRender: function() {\n            // Checks to see if the accordion should be reset on revisit\n            this.checkIfResetOnRevisit();\n        },\n\n        postRender: function() {\n            this.setReadyStatus();\n        },\n\n        // Used to check if the accordion should reset on revisit\n        checkIfResetOnRevisit: function() {\n            var isResetOnRevisit = this.model.get('_isResetOnRevisit');\n\n            // If reset is enabled set defaults\n            if (isResetOnRevisit) {\n                this.model.reset(isResetOnRevisit);\n            }\n\n            _.each(this.model.get('_items'), function(item) {\n                item._isVisited = false;\n            });\n        },\n\n        toggleItem: function(event) {\n            event.preventDefault();\n            this.$('.accordion-item-body').stop(true, true).slideUp(200);\n\n            if (!$(event.currentTarget).hasClass('selected')) {\n                this.$('.accordion-item-title').removeClass('selected');\n                var body = $(event.currentTarget).addClass('selected visited').siblings('.accordion-item-body').slideToggle(200, function() {\n                  $(body).a11y_focus();\n                });\n                this.$('.accordion-item-title-icon').removeClass('icon-minus').addClass('icon-plus');\n                $('.accordion-item-title-icon', event.currentTarget).removeClass('icon-plus').addClass('icon-minus');\n\n                if ($(event.currentTarget).hasClass('accordion-item')) {\n                    this.setVisited($(event.currentTarget).index());\n                } else {\n                    this.setVisited($(event.currentTarget).parent('.accordion-item').index());\n                }\n            } else {\n                this.$('.accordion-item-title').removeClass('selected');\n                $(event.currentTarget).removeClass('selected');\n                $('.accordion-item-title-icon', event.currentTarget).removeClass('icon-minus').addClass('icon-plus');\n            }\n            // set aria-expanded value\n            if ($(event.currentTarget).hasClass('selected')) {\n                $('.accordion-item-title').attr('aria-expanded', false);\n                $(event.currentTarget).attr('aria-expanded', true);\n            } else {\n                $(event.currentTarget).attr('aria-expanded', false);\n            }\n        },\n\n        setVisited: function(index) {\n            var item = this.model.get('_items')[index];\n            item._isVisited = true;\n            this.checkCompletionStatus();\n        },\n\n        getVisitedItems: function() {\n            return _.filter(this.model.get('_items'), function(item) {\n                return item._isVisited;\n            });\n        },\n\n        checkCompletionStatus: function() {\n            if (this.getVisitedItems().length == this.model.get('_items').length) {\n                this.setCompletionStatus();\n            }\n        }\n\n    });\n\n    Adapt.register('accordion', Accordion);\n\n    return Accordion;\n\n});\n\n","define('components/adapt-contrib-text/js/adapt-contrib-text',['require','coreViews/componentView','coreJS/adapt'],function(require) {\n\n    var ComponentView = require('coreViews/componentView');\n    var Adapt = require('coreJS/adapt');\n\n    var Text = ComponentView.extend({\n\n        preRender: function() {\n            // Checks to see if the text should be reset on revisit\n            this.checkIfResetOnRevisit();\n        },\n\n        postRender: function() {\n            this.setReadyStatus();\n\n            // Check if instruction or title or body is set, otherwise force completion\n            var cssSelector = this.$('.component-instruction').length > 0\n                ? '.component-instruction'\n                : (this.$('.component-title').length > 0 \n                ? '.component-title' \n                : (this.$('.component-body').length > 0 \n                ? '.component-body' \n                : null));\n\n            if (!cssSelector) {\n                this.setCompletionStatus();\n            } else {\n                this.model.set('cssSelector', cssSelector);\n                this.$(cssSelector).on('inview', _.bind(this.inview, this));\n            }\n        },\n\n        // Used to check if the text should reset on revisit\n        checkIfResetOnRevisit: function() {\n            var isResetOnRevisit = this.model.get('_isResetOnRevisit');\n\n            // If reset is enabled set defaults\n            if (isResetOnRevisit) {\n                this.model.reset(isResetOnRevisit);\n            }\n        },\n\n        inview: function(event, visible, visiblePartX, visiblePartY) {\n            if (visible) {\n                if (visiblePartY === 'top') {\n                    this._isVisibleTop = true;\n                } else if (visiblePartY === 'bottom') {\n                    this._isVisibleBottom = true;\n                } else {\n                    this._isVisibleTop = true;\n                    this._isVisibleBottom = true;\n                }\n\n                if (this._isVisibleTop && this._isVisibleBottom) {\n                    this.$(this.model.get('cssSelector')).off('inview');\n                    this.setCompletionStatus();\n                }\n            }\n        }\n\n    });\n\n    Adapt.register('text', Text);\n\n    return Text;\n\n});\n\n","define('menu/adapt-contrib-boxmenu/js/adapt-contrib-boxmenu',[\n    'coreJS/adapt',\n    'coreViews/menuView'\n], function(Adapt, MenuView) {\n\n    var BoxMenuView = MenuView.extend({\n\n        postRender: function() {\n            var nthChild = 0;\n            this.model.getChildren().each(function(item) {\n                if (item.get('_isAvailable')) {\n                    nthChild++;\n                    item.set(\"_nthChild\", nthChild);\n                    this.$('.menu-container-inner').append(new BoxMenuItemView({model: item}).$el);\n                }\n            });\n        }\n\n    }, {\n        template: 'boxmenu'\n    });\n\n    var BoxMenuItemView = MenuView.extend({\n\n        events: {\n            'click button' : 'onClickMenuItemButton'\n        },\n\n        className: function() {\n            var nthChild = this.model.get(\"_nthChild\");\n            return [\n                'menu-item',\n                'menu-item-' + this.model.get('_id') ,\n                this.model.get('_classes'),\n                'nth-child-' + nthChild,\n                nthChild % 2 === 0 ? 'nth-child-even' : 'nth-child-odd'\n            ].join(' ');\n        },\n\n        preRender: function() {\n            this.model.checkCompletionStatus();\n            this.model.checkInteractionCompletionStatus();\n        },\n\n        postRender: function() {\n            var graphic = this.model.get('_graphic');\n            if (graphic && graphic.src && graphic.src.length > 0) {\n                this.$el.imageready(_.bind(function() {\n                    this.setReadyStatus();\n                }, this));\n            } else {\n                this.setReadyStatus();\n            }\n        },\n\n        onClickMenuItemButton: function(event) {\n            if(event && event.preventDefault) event.preventDefault();\n            Backbone.history.navigate('#/id/' + this.model.get('_id'), {trigger: true});\n        }\n\n    }, {\n        template: 'boxmenu-item'\n    });\n\n    Adapt.on('router:menu', function(model) {\n\n        $('#wrapper').append(new BoxMenuView({model: model}).$el);\n\n    });\n\n});\n\n","define('theme/adapt-contrib-vanilla/js/theme-block',['require','coreJS/adapt','backbone'],function(require) {\n\t\n\tvar Adapt = require('coreJS/adapt');\n\tvar Backbone = require('backbone');\n\n\tvar ThemeBlockView = Backbone.View.extend({\n\n\t\tinitialize: function() {\n\t\t\tthis.setStyles();\n\t\t\tthis.listenTo(Adapt, 'device:resize', this.setStyles);\n\t\t\tthis.listenTo(Adapt, 'remove', this.remove);\n\t\t},\n\n\t\tsetStyles: function() {\n\t\t\tthis.setBackground();\n\t\t\tthis.setMinHeight();\n\t\t\tthis.setDividerBlock();\n\t\t},\n\n\t\tsetBackground: function() {\n\t\t\tvar backgroundColor = this.model.get('_themeBlockConfig')._backgroundColor;\n\t\t\t\n\t\t\tif (backgroundColor) {\n\t\t\t\tthis.$el.addClass(backgroundColor);\n\t\t\t}\n\t\t},\n\n\t\tsetMinHeight: function() {\n\t\t\tvar minHeight = 0;\n\t\t\tvar minHeights = this.model.get('_themeBlockConfig')._minimumHeights;\n\n\t\t\tif (minHeights) {\n\n\t\t\t\tif(Adapt.device.screenSize == 'large') {\n\t\t\t\t\tminHeight = minHeights._large;\n\t\t\t\t} else if (Adapt.device.screenSize == 'medium') {\n\t\t\t\t\tminHeight = minHeights._medium;\n\t\t\t\t} else {\n\t\t\t\t\tminHeight = minHeights._small;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.$el.css({\n\t\t\t\tminHeight: minHeight + \"px\"\n\t\t\t});\n\t\t},\n\n\t\tsetDividerBlock: function() {\n\t\t\tvar dividerBlock = this.model.get('_themeBlockConfig')._isDividerBlock;\n\n\t\t\tif (dividerBlock) {\n\t\t\t\tthis.$el.addClass('divider-block');\n\t\t\t}\n\t\t}\n\t});\n\n\treturn ThemeBlockView;\n\t\n});\n\n","define('theme/adapt-contrib-vanilla/js/vanilla',['require','coreJS/adapt','backbone','theme/adapt-contrib-vanilla/js/theme-block'],function(require) {\n\t\n\tvar Adapt = require('coreJS/adapt');\n\tvar Backbone = require('backbone');\n\tvar ThemeBlock = require('theme/adapt-contrib-vanilla/js/theme-block');\n\n\t// Block View\n\t// ==========\n\n\tAdapt.on('blockView:postRender', function(view) {\n\t\tvar theme = view.model.get('_theme');\n\t\t\n\t\tif (theme) {\n\t\t\tnew ThemeBlock({\n\t\t\t\tmodel: new Backbone.Model({\n\t\t\t\t\t_themeBlockConfig: theme\n\t\t\t\t}),\n\t\t\t\tel: view.$el\n\t\t\t});\n\t\t}\n\t});\n});\n\n","define('bundles',[\n\t\"extensions/adapt-contrib-pageLevelProgress/js/adapt-contrib-pageLevelProgress\",\n\t\"extensions/adapt-contrib-resources/js/adapt-contrib-resources\",\n\t\"extensions/adapt-contrib-spoor/js/adapt-contrib-spoor\",\n\t\"extensions/adapt-contrib-trickle/js/adapt-contrib-trickle\",\n\t\"extensions/adapt-contrib-tutor/js/adapt-contrib-tutor\",\n\t\"components/adapt-contrib-accordion/js/adapt-contrib-accordion\",\n\t\"components/adapt-contrib-text/js/adapt-contrib-text\",\n\t\"menu/adapt-contrib-boxmenu/js/adapt-contrib-boxmenu\",\n\t\"theme/adapt-contrib-vanilla/js/vanilla\"\n],function(){});\n"]}